import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussBoardPostReaction } from "../../../../structures/IDiscussBoardPostReaction";
import { IPageIDiscussBoardPostReaction } from "../../../../structures/IPageIDiscussBoardPostReaction";

/**
 * Create a new post reaction (like/dislike) for a post
 * (discuss_board_post_reactions).
 *
 * Allows a member to create a like or dislike reaction to a post. Enforces
 * uniqueness (one reaction per member/post) and ensures input conformance (the
 * reaction_type field must be 'like' or 'dislike').
 *
 * On submission, business logic checks for existing reactions by the member for
 * the post, updating or toggling as required by platform rules. Rate limiting,
 * anti-abuse checks, and moderation triggers are integrated with this
 * endpoint.
 *
 * Strict authorization ensures only authenticated members may create reactions.
 * Attempts to submit duplicate or invalid reactions are rejected with
 * clarification.
 *
 * @param props.connection
 * @param props.body Reaction creation data (target post, reaction type, etc.)
 * @path /discussBoard/member/postReactions
 * @accessor api.functional.discussBoard.member.postReactions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Reaction creation data (target post, reaction type, etc.) */
    body: IDiscussBoardPostReaction.ICreate;
  };
  export type Body = IDiscussBoardPostReaction.ICreate;
  export type Response = IDiscussBoardPostReaction;

  export const METADATA = {
    method: "POST",
    path: "/discussBoard/member/postReactions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussBoard/member/postReactions";
  export const random = (): IDiscussBoardPostReaction =>
    typia.random<IDiscussBoardPostReaction>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/filter post reactions (discuss_board_post_reactions) with pagination
 * support.
 *
 * Retrieve a paginated list of reactions (likes/dislikes) on posts. Supports
 * parameters for filtering by member, post, reaction type, or time range, as
 * defined in the discuss_board_post_reactions model. The summary response aids
 * analytics, reputation tracking, and moderation audits.
 *
 * This endpoint is essential for both user-facing features (displaying reaction
 * counts, toggling reactions) and administrative functions (identifying spam,
 * abuse, or manipulation of reaction features).
 *
 * Public information (aggregated counts) may be accessed by guests, while
 * detailed member-specific reactions require appropriate authorization.
 *
 * @param props.connection
 * @param props.body Filter and pagination criteria for post reactions (member,
 *   post, reaction type, etc.).
 * @path /discussBoard/member/postReactions
 * @accessor api.functional.discussBoard.member.postReactions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter and pagination criteria for post reactions (member, post,
     * reaction type, etc.).
     */
    body: IDiscussBoardPostReaction.IRequest;
  };
  export type Body = IDiscussBoardPostReaction.IRequest;
  export type Response = IPageIDiscussBoardPostReaction.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussBoard/member/postReactions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussBoard/member/postReactions";
  export const random = (): IPageIDiscussBoardPostReaction.ISummary =>
    typia.random<IPageIDiscussBoardPostReaction.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific post reaction record (discuss_board_post_reactions) by ID.
 *
 * Get a single post reaction record by its ID. Returns information such as who
 * reacted, to which post, what type of reaction, and creation/update
 * timestamps. This enables reaction management, auditing, and personalized
 * features (e.g. reaction toggles for current user).
 *
 * Access to detailed records is typically limited to the reactor, target post
 * owner, or privileged staff, enabling transparency while protecting privacy.
 * Unauthorized access results in appropriate errors, and all access is
 * auditable.
 *
 * @param props.connection
 * @param props.postReactionId UUID of the post reaction record to retrieve.
 * @path /discussBoard/member/postReactions/:postReactionId
 * @accessor api.functional.discussBoard.member.postReactions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the post reaction record to retrieve. */
    postReactionId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussBoardPostReaction;

  export const METADATA = {
    method: "GET",
    path: "/discussBoard/member/postReactions/:postReactionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussBoard/member/postReactions/${encodeURIComponent(props.postReactionId ?? "null")}`;
  export const random = (): IDiscussBoardPostReaction =>
    typia.random<IDiscussBoardPostReaction>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postReactionId")(() => typia.assert(props.postReactionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing post reaction (toggle like/dislike)
 * (discuss_board_post_reactions).
 *
 * Enables a member to update their reaction on a given post, typically toggling
 * between 'like' and 'dislike', or correcting an input. The request body must
 * specify the new state, conforming to the allowed reaction_type values.
 *
 * The endpoint enforces integrity rulesâ€”there can only be one active reaction
 * per member/post. Abusive or invalid requests are rejected with error
 * messages. Only the reaction's owner or authorized staff can perform updates.
 * All changes are logged for audit and for possible rollbacks or dispute
 * resolution.
 *
 * @param props.connection
 * @param props.postReactionId UUID of the post reaction to update.
 * @param props.body Update data for the reaction (reaction type, etc.)
 * @path /discussBoard/member/postReactions/:postReactionId
 * @accessor api.functional.discussBoard.member.postReactions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the post reaction to update. */
    postReactionId: string & tags.Format<"uuid">;

    /** Update data for the reaction (reaction type, etc.) */
    body: IDiscussBoardPostReaction.IUpdate;
  };
  export type Body = IDiscussBoardPostReaction.IUpdate;
  export type Response = IDiscussBoardPostReaction;

  export const METADATA = {
    method: "PUT",
    path: "/discussBoard/member/postReactions/:postReactionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussBoard/member/postReactions/${encodeURIComponent(props.postReactionId ?? "null")}`;
  export const random = (): IDiscussBoardPostReaction =>
    typia.random<IDiscussBoardPostReaction>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postReactionId")(() => typia.assert(props.postReactionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (soft-delete) a post reaction (discuss_board_post_reactions).
 *
 * Delete a member's reaction (like/dislike) to a post. The operation marks the
 * reaction as deleted by setting the deleted_at timestamp, ensuring the action
 * is reversible and all audit/history/aggregate information remains accurate.
 *
 * Authorization ensures that only the member performing the original reaction,
 * authorized staff, or moderators can delete the reaction record. Abusive or
 * repeated deletion attempts are prevented by business policy.
 *
 * Audit logs and aggregate reaction counts are updated appropriately to reflect
 * the removal. All delete actions are tracked for compliance and can be
 * reviewed by administrators.
 *
 * @param props.connection
 * @param props.postReactionId UUID of the post reaction to delete.
 * @path /discussBoard/member/postReactions/:postReactionId
 * @accessor api.functional.discussBoard.member.postReactions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the post reaction to delete. */
    postReactionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussBoard/member/postReactions/:postReactionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussBoard/member/postReactions/${encodeURIComponent(props.postReactionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postReactionId")(() => typia.assert(props.postReactionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
