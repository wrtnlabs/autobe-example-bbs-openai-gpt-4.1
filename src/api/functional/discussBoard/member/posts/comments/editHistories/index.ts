import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussBoardCommentEditHistory } from "../../../../../../structures/IDiscussBoardCommentEditHistory";
import { IPageIDiscussBoardCommentEditHistory } from "../../../../../../structures/IPageIDiscussBoardCommentEditHistory";

/**
 * Paginate and search comment edit histories
 * (discuss_board_comment_edit_histories).
 *
 * This operation retrieves a paginated, filterable list of all edit events for
 * a specific comment, as defined in the discuss_board_comment_edit_histories
 * schema. Provides audit-trail data for tracking all edits made to comment
 * content, status, or editor notes, allowing compliance review and rollback as
 * per business rules. Query filters support search by editor, date, or reason
 * for edit, with sort and pagination for large histories.
 *
 * Access control ensures only authorized users (comment author, moderators,
 * admins) view full histories; guests do not have access. Each history entry
 * shows who edited, when, previous content, status, and editorial notes,
 * supporting rich UI features like timeline views or detailed compliance
 * reporting. Critical for transparent discussion moderation and evidentiary
 * requirements in appeals.
 *
 * @param props.connection
 * @param props.postId UUID of the post containing the comment.
 * @param props.commentId UUID of the comment whose edit history is being
 *   queried.
 * @param props.body Edit history search, filtering, and pagination
 *   specification.
 * @path /discussBoard/member/posts/:postId/comments/:commentId/editHistories
 * @accessor api.functional.discussBoard.member.posts.comments.editHistories.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the post containing the comment. */
    postId: string & tags.Format<"uuid">;

    /** UUID of the comment whose edit history is being queried. */
    commentId: string & tags.Format<"uuid">;

    /** Edit history search, filtering, and pagination specification. */
    body: IDiscussBoardCommentEditHistory.IRequest;
  };
  export type Body = IDiscussBoardCommentEditHistory.IRequest;
  export type Response = IPageIDiscussBoardCommentEditHistory;

  export const METADATA = {
    method: "PATCH",
    path: "/discussBoard/member/posts/:postId/comments/:commentId/editHistories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussBoard/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/editHistories`;
  export const random = (): IPageIDiscussBoardCommentEditHistory =>
    typia.random<IPageIDiscussBoardCommentEditHistory>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a single comment edit history record.
 *
 * This operation fetches the complete details of a single edit event for a
 * comment, based on the discuss_board_comment_edit_histories table record. All
 * required IDs are path parameters: postId (parent post), commentId (parent
 * comment), and editHistoryId (the specific edit event). Contains full snapshot
 * of prior content, business status, editor, and any editor-provided note with
 * UTC timestamp for audit and timeline display.
 *
 * Access is restricted to the comment author, moderators, or administrators.
 * Used for deep-dive compliance investigation, restoration UI, or trusted
 * history reviews in appeals. Works in conjunction with the edit history list
 * and rollback endpoints.
 *
 * @param props.connection
 * @param props.postId UUID of the post containing the comment (hierarchy for
 *   context).
 * @param props.commentId UUID of the comment for which edit history is
 *   requested.
 * @param props.editHistoryId UUID of the specific edit history record to
 *   retrieve.
 * @path /discussBoard/member/posts/:postId/comments/:commentId/editHistories/:editHistoryId
 * @accessor api.functional.discussBoard.member.posts.comments.editHistories.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the post containing the comment (hierarchy for context). */
    postId: string & tags.Format<"uuid">;

    /** UUID of the comment for which edit history is requested. */
    commentId: string & tags.Format<"uuid">;

    /** UUID of the specific edit history record to retrieve. */
    editHistoryId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussBoardCommentEditHistory;

  export const METADATA = {
    method: "GET",
    path: "/discussBoard/member/posts/:postId/comments/:commentId/editHistories/:editHistoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussBoard/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/editHistories/${encodeURIComponent(props.editHistoryId ?? "null")}`;
  export const random = (): IDiscussBoardCommentEditHistory =>
    typia.random<IDiscussBoardCommentEditHistory>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("editHistoryId")(() => typia.assert(props.editHistoryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
