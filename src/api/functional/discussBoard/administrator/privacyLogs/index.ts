import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussBoardPrivacyLogs } from "../../../../structures/IDiscussBoardPrivacyLogs";
import { IPageIDiscussBoardPrivacyLogs } from "../../../../structures/IPageIDiscussBoardPrivacyLogs";

/**
 * Retrieve a paginated and filterable set of privacy action logs.
 *
 * Retrieve a paginated, filterable list of privacy logs documenting all
 * privacy-relevant actions on user data, such as exports, deletions, consent
 * changes, or policy modifications. Each log entry in the
 * discuss_board_privacy_logs table contains identifiers for the actor/subject,
 * type of action performed, and the associated result status. This operation
 * supports audit processes and regular compliance checks.
 *
 * Filters may include actor_user_account_id, data_subject_user_account_id,
 * action_type, result_status, and timestamp ranges. Due to the sensitivity of
 * privacy logs, only administrators may use this endpoint. Related operations
 * include fetching individual log details and searching by user or event type.
 *
 * Proper error messages are returned when filters are invalid or no logs match
 * the given criteria.
 *
 * @param props.connection
 * @param props.body Filter and pagination data for searching privacy logs.
 * @path /discussBoard/administrator/privacyLogs
 * @accessor api.functional.discussBoard.administrator.privacyLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter and pagination data for searching privacy logs. */
    body: IDiscussBoardPrivacyLogs.IRequest;
  };
  export type Body = IDiscussBoardPrivacyLogs.IRequest;
  export type Response = IPageIDiscussBoardPrivacyLogs;

  export const METADATA = {
    method: "PATCH",
    path: "/discussBoard/administrator/privacyLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussBoard/administrator/privacyLogs";
  export const random = (): IPageIDiscussBoardPrivacyLogs =>
    typia.random<IPageIDiscussBoardPrivacyLogs>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch details of a specific privacy log entry by ID.
 *
 * Fetch the complete details for a single privacy log entry covering a
 * sensitive user data operation, identified by privacyLogId. The record
 * contains the acting user's ID and the data subject's ID (if applicable), the
 * type of operation (access, export, delete, policy change), the business
 * reason or outcome, and the exact timestamp of the event.
 *
 * Access is strictly limited to administrator users due to legal risk and
 * privacy obligations. Errors are returned if the requested log entry does not
 * exist or access is denied. This API is typically used for internal audit,
 * compliance checks, and incident investigation workflows.
 *
 * This operation complements the list/search of privacy logs and may be
 * referenced in compliance reports or external audits.
 *
 * @param props.connection
 * @param props.privacyLogId Unique identifier of the privacy log entry to
 *   retrieve.
 * @path /discussBoard/administrator/privacyLogs/:privacyLogId
 * @accessor api.functional.discussBoard.administrator.privacyLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the privacy log entry to retrieve. */
    privacyLogId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussBoardPrivacyLogs;

  export const METADATA = {
    method: "GET",
    path: "/discussBoard/administrator/privacyLogs/:privacyLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussBoard/administrator/privacyLogs/${encodeURIComponent(props.privacyLogId ?? "null")}`;
  export const random = (): IDiscussBoardPrivacyLogs =>
    typia.random<IDiscussBoardPrivacyLogs>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("privacyLogId")(() => typia.assert(props.privacyLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
