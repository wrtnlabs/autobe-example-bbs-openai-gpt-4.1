import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussBoardAdministrator } from "../../../../structures/IDiscussBoardAdministrator";
import { IPageIDiscussBoardAdministrator } from "../../../../structures/IPageIDiscussBoardAdministrator";

/**
 * Search and paginate administrator accounts in discuss_board_administrators.
 *
 * Use this endpoint to search the discuss_board_administrators table for
 * administrator accounts. It supports advanced filtering by status (active,
 * resigned, suspended), assignment/escalation history, creation or status
 * update dates, and can sort by timestamps or status values.
 *
 * Pagination and search options help with administrative oversight, audit, and
 * compliance reviews of platform superusers. Returned fields cover
 * administrator/member linkage, escalation metadata, and current admin status.
 * Security is strict: only other administrators may search the admin directory.
 * Members, moderators, or guests are explicitly denied access to this
 * function.
 *
 * The request body allows specifying search filters, sort keys, and pagination
 * limits. The response is a paginated array of administrator summary objects,
 * optimized for audit dashboards or internal policy review.
 *
 * Error responses include unauthorized access, malformed search queries, and
 * database errors. Related operations for creating, modifying, or deleting
 * administrator roles are available in separate endpoints, all restricted to
 * administrator users.
 *
 * @param props.connection
 * @param props.body Filter, sort, and pagination criteria for administrators
 *   search.
 * @path /discussBoard/administrator/administrators
 * @accessor api.functional.discussBoard.administrator.administrators.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter, sort, and pagination criteria for administrators search. */
    body: IDiscussBoardAdministrator.IRequest;
  };
  export type Body = IDiscussBoardAdministrator.IRequest;
  export type Response = IPageIDiscussBoardAdministrator.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussBoard/administrator/administrators",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussBoard/administrator/administrators";
  export const random = (): IPageIDiscussBoardAdministrator.ISummary =>
    typia.random<IPageIDiscussBoardAdministrator.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single administrator account detail by administratorId from
 * discuss_board_administrators.
 *
 * Use this endpoint to retrieve all profile and role metadata for a single
 * platform administrator. The discuss_board_administrators table links
 * administrator role assignments directly to member accounts, tracks
 * assignment/revocation history, and contains business fields for auditing.
 *
 * Returned data includes admin assignment/escalation origin, current status,
 * assignment and revocation dates, and associated member account metadata. The
 * endpoint enforces strict access controlâ€”only administrator users may query
 * individual administrator details.
 *
 * Security logic ensures that records found by administratorId exist, are not
 * soft-deleted, and that the requesting user is authorized for high-privilege
 * data access. Attempts to reference invalid or revoked administratorId values
 * result in precise 404/403 error codes.
 *
 * For managing or updating admin roles, separate endpoints exist. For
 * audit/history, the payload contains timestamps for creation, updates, and
 * revocation if relevant. This operation is core to platform governance and
 * role verification flows.
 *
 * @param props.connection
 * @param props.administratorId Unique identifier for the administrator account
 *   (UUID).
 * @path /discussBoard/administrator/administrators/:administratorId
 * @accessor api.functional.discussBoard.administrator.administrators.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the administrator account (UUID). */
    administratorId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussBoardAdministrator;

  export const METADATA = {
    method: "GET",
    path: "/discussBoard/administrator/administrators/:administratorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussBoard/administrator/administrators/${encodeURIComponent(props.administratorId ?? "null")}`;
  export const random = (): IDiscussBoardAdministrator =>
    typia.random<IDiscussBoardAdministrator>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("administratorId")(() =>
        typia.assert(props.administratorId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update administrator account properties in discuss_board_administrators by
 * administratorId.
 *
 * Administrators may use this endpoint to change the properties of an
 * administrator account, identified by administratorId. Common update scenarios
 * include adjusting admin status (e.g., suspended, resigned), correcting
 * escalation data, or updating administrative metadata per audit requirements.
 * The full set of updatable fields corresponds to the
 * discuss_board_administrators schema.
 *
 * Only an administrator may update another administrator's records, and the
 * requesting user must have escalation permissions over the target record.
 * Updates trigger audit logging to ensure compliance.
 *
 * Request body validation ensures all modifications are business-legal (cannot
 * demote self without secondary confirmation, cannot assign statuses not
 * present in admin status enum, etc.). Only unrevoked records can be altered.
 * The response payload returns the updated administrator account entity,
 * reflecting all business-enforced changes.
 *
 * Error cases include invalid administratorId, disallowed status transitions,
 * or lack of sufficient permissions. Update operations on revoked/deleted admin
 * accounts are rejected with explanatory error messages.
 *
 * @param props.connection
 * @param props.administratorId Unique identifier for the target administrator
 *   account (UUID) to update.
 * @param props.body Update-able administrator account information for the
 *   target admin.
 * @path /discussBoard/administrator/administrators/:administratorId
 * @accessor api.functional.discussBoard.administrator.administrators.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier for the target administrator account (UUID) to
     * update.
     */
    administratorId: string & tags.Format<"uuid">;

    /** Update-able administrator account information for the target admin. */
    body: IDiscussBoardAdministrator.IUpdate;
  };
  export type Body = IDiscussBoardAdministrator.IUpdate;
  export type Response = IDiscussBoardAdministrator;

  export const METADATA = {
    method: "PUT",
    path: "/discussBoard/administrator/administrators/:administratorId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussBoard/administrator/administrators/${encodeURIComponent(props.administratorId ?? "null")}`;
  export const random = (): IDiscussBoardAdministrator =>
    typia.random<IDiscussBoardAdministrator>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("administratorId")(() =>
        typia.assert(props.administratorId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke (soft-delete) administrator account and privileges in
 * discuss_board_administrators by administratorId.
 *
 * Administrators can use this endpoint to remove administrator privileges from
 * a platform user, identified by administratorId. The operation marks the
 * target record as soft-deleted (deleted_at filled) according to the schema,
 * thus retaining full audit trail for compliance and investigations.
 *
 * Self-deletion is permitted only with additional authentication in production
 * logic. The endpoint enforces business logic preventing deletion of the final
 * remaining admin to ensure platform coverage. The deletion operation is logged
 * for audit and recovery.
 *
 * Requests with invalid or already revoked administratorId are rejected with
 * detailed errors. Associated member records remain intact; only privileges at
 * the administrator level are impacted. Complete action results in the removal
 * of admin access and privilege escalation rights for the target account.
 *
 * No entity is physically removed from the database; record retention follows
 * organizational compliance and data recovery best practices.
 *
 * @param props.connection
 * @param props.administratorId Unique administrator account identifier for
 *   privilege revocation (UUID).
 * @path /discussBoard/administrator/administrators/:administratorId
 * @accessor api.functional.discussBoard.administrator.administrators.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique administrator account identifier for privilege revocation
     * (UUID).
     */
    administratorId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussBoard/administrator/administrators/:administratorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussBoard/administrator/administrators/${encodeURIComponent(props.administratorId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("administratorId")(() =>
        typia.assert(props.administratorId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
