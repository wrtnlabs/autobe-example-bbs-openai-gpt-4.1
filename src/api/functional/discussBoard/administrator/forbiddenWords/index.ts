import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussBoardForbiddenWords } from "../../../../structures/IDiscussBoardForbiddenWords";
import { IPageIDiscussBoardForbiddenWords } from "../../../../structures/IPageIDiscussBoardForbiddenWords";

/**
 * Create a new forbidden word moderation rule (discuss_board_forbidden_words
 * table).
 *
 * Adds a new entry to the forbidden words/phrases list for discussBoard,
 * enforcing new policy rules for future content. Payload must define the
 * expression/pattern, optional description/rationale, and is validated for
 * uniqueness (expression must not duplicate existing records,
 * case-insensitive).
 *
 * Strictly restricted to administrative roles due to significant impact on user
 * content moderation and censorship. The creation is auditable, triggers policy
 * update notifications to moderation teams, and can be rolled back or
 * soft-deleted if needed. This is coordinated with the forbidden word index
 * endpoint and supports platform-level compliance.
 *
 * @param props.connection
 * @param props.body Data describing the new forbidden word to add
 * @path /discussBoard/administrator/forbiddenWords
 * @accessor api.functional.discussBoard.administrator.forbiddenWords.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Data describing the new forbidden word to add */
    body: IDiscussBoardForbiddenWords.ICreate;
  };
  export type Body = IDiscussBoardForbiddenWords.ICreate;
  export type Response = IDiscussBoardForbiddenWords;

  export const METADATA = {
    method: "POST",
    path: "/discussBoard/administrator/forbiddenWords",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussBoard/administrator/forbiddenWords";
  export const random = (): IDiscussBoardForbiddenWords =>
    typia.random<IDiscussBoardForbiddenWords>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search forbidden word rules for content moderation
 * (discuss_board_forbidden_words table).
 *
 * Returns a paginated list of forbidden words/phrases/regex patterns currently
 * enforced for post and comment filtering, as records from the
 * discuss_board_forbidden_words table. Supports filtering, search, and
 * sorting.
 *
 * Primarily for administrators (or moderators) managing platform compliance and
 * community standards. Typical use cases include reviewing current forbidden
 * word policies, responding to regulatory audits, or performing bulk edits.
 * Soft-deleted entries are not included unless specifically searched for by
 * authorized personnel. This is usually paired with endpoints for adding,
 * updating, or deleting forbidden keyword rules.
 *
 * Strict authorization required: Only administrators and sometimes moderators
 * may view or manage the forbidden words list.
 *
 * @param props.connection
 * @param props.body Filtering and pagination criteria for forbidden keyword
 *   rules
 * @path /discussBoard/administrator/forbiddenWords
 * @accessor api.functional.discussBoard.administrator.forbiddenWords.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filtering and pagination criteria for forbidden keyword rules */
    body: IDiscussBoardForbiddenWords.IRequest;
  };
  export type Body = IDiscussBoardForbiddenWords.IRequest;
  export type Response = IPageIDiscussBoardForbiddenWords;

  export const METADATA = {
    method: "PATCH",
    path: "/discussBoard/administrator/forbiddenWords",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussBoard/administrator/forbiddenWords";
  export const random = (): IPageIDiscussBoardForbiddenWords =>
    typia.random<IPageIDiscussBoardForbiddenWords>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get forbidden word rule detail (discuss_board_forbidden_words table).
 *
 * Retrieves the complete specification for a single forbidden word, phrase, or
 * regex rule used for content filtering on discussBoard. The record is
 * identified by its unique UUID as the forbiddenWordId parameter.
 *
 * The endpoint returns all fields from discuss_board_forbidden_words, including
 * expression, description/rationale, and timestamps (created_at, updated_at,
 * deleted_at if soft-deleted).
 *
 * Standard error responses include not-found for invalid ID, permission denied
 * for unauthorized roles, and possibly auditing soft-deleted rules for
 * compliance. Used in content moderation configuration UIs and administrative
 * audit workflows.
 *
 * @param props.connection
 * @param props.forbiddenWordId UUID of the forbidden words record to retrieve
 * @path /discussBoard/administrator/forbiddenWords/:forbiddenWordId
 * @accessor api.functional.discussBoard.administrator.forbiddenWords.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the forbidden words record to retrieve */
    forbiddenWordId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussBoardForbiddenWords;

  export const METADATA = {
    method: "GET",
    path: "/discussBoard/administrator/forbiddenWords/:forbiddenWordId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussBoard/administrator/forbiddenWords/${encodeURIComponent(props.forbiddenWordId ?? "null")}`;
  export const random = (): IDiscussBoardForbiddenWords =>
    typia.random<IDiscussBoardForbiddenWords>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forbiddenWordId")(() =>
        typia.assert(props.forbiddenWordId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing forbidden word rule (discuss_board_forbidden_words table).
 *
 * Updates a forbidden words record by its unique ID, allowing modification of
 * the expression, rationale, or other properties for compliance or moderation
 * policy changes. Supports audit logging and validation for unique expressions
 * (case-insensitive).
 *
 * Strictly restricted to administrative roles. When an existing forbidden word
 * is changed, system policy update logic may notify affected services or
 * moderation users. Related to creation, deletion, and listing endpoints.
 *
 * @param props.connection
 * @param props.forbiddenWordId UUID of the forbidden word filtering rule to
 *   update
 * @param props.body Forbidden words update payload (expression, description,
 *   etc.)
 * @path /discussBoard/administrator/forbiddenWords/:forbiddenWordId
 * @accessor api.functional.discussBoard.administrator.forbiddenWords.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the forbidden word filtering rule to update */
    forbiddenWordId: string & tags.Format<"uuid">;

    /** Forbidden words update payload (expression, description, etc.) */
    body: IDiscussBoardForbiddenWords.IUpdate;
  };
  export type Body = IDiscussBoardForbiddenWords.IUpdate;
  export type Response = IDiscussBoardForbiddenWords;

  export const METADATA = {
    method: "PUT",
    path: "/discussBoard/administrator/forbiddenWords/:forbiddenWordId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussBoard/administrator/forbiddenWords/${encodeURIComponent(props.forbiddenWordId ?? "null")}`;
  export const random = (): IDiscussBoardForbiddenWords =>
    typia.random<IDiscussBoardForbiddenWords>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forbiddenWordId")(() =>
        typia.assert(props.forbiddenWordId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a forbidden word rule (discuss_board_forbidden_words table).
 *
 * Removes (soft deletes) a forbidden word or phrase from the moderation
 * filtering policy by marking deleted_at on the record. This prevents further
 * enforcement against this expression but keeps the record for audit,
 * transparency, or potential future restoration.
 *
 * Strict authorization is required: Only administrators can delete forbidden
 * word rules. Audit logs must capture who deleted the rule, when, and the
 * business rationale. Errors include not found (invalid ID), already deleted,
 * or permission denied.
 *
 * Typically coordinated with list and create endpoints for comprehensive
 * moderation management.
 *
 * @param props.connection
 * @param props.forbiddenWordId UUID of the forbidden word rule to delete (soft
 *   delete marks deleted_at)
 * @path /discussBoard/administrator/forbiddenWords/:forbiddenWordId
 * @accessor api.functional.discussBoard.administrator.forbiddenWords.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * UUID of the forbidden word rule to delete (soft delete marks
     * deleted_at)
     */
    forbiddenWordId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussBoard/administrator/forbiddenWords/:forbiddenWordId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussBoard/administrator/forbiddenWords/${encodeURIComponent(props.forbiddenWordId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forbiddenWordId")(() =>
        typia.assert(props.forbiddenWordId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
