import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardModerator } from "../../../structures/IDiscussionBoardModerator";

/**
 * Register a new moderator account and issue initial tokens
 * (discussion_board_users + discussion_board_moderators).
 *
 * This operation allows a new moderator to register an account in the system.
 * It creates a new row in discussion_board_users (which stores authentication
 * credentials for all user-like roles) and issues a JWT access/refresh token
 * pair with role='moderator'. The operation requires (and validates) a unique
 * email and usernameâ€”the fields enforced by the discussion_board_users schema.
 * During registration, password_hash is stored securely, and is_verified is set
 * to false until the moderator completes email confirmation. Upon user
 * creation, the discussion_board_moderators table is updated to link this user
 * with moderator privileges (with assigned_at timestamp set to now, is_active
 * true, and revoked_at null). Security-critical fields such as password_hash
 * and email must adhere to complexity and uniqueness requirements, and any
 * business rule violation will be rejected. This endpoint does not permit
 * immediate login until email is verified, as managed by other schema tables
 * (verification flows not explicitly handled by this call). Works in
 * conjunction with moderator login, token refresh, and email verification
 * APIs.
 *
 * @param props.connection
 * @param props.body Moderator registration info (email, username, password,
 *   profile).
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Moderator registration info (email, username, password, profile). */
    body: IDiscussionBoardModerator.IJoin;
  };
  export type Body = IDiscussionBoardModerator.IJoin;
  export type Response = IDiscussionBoardModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/join";
  export const random = (): IDiscussionBoardModerator.IAuthorized =>
    typia.random<IDiscussionBoardModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate moderator and issue tokens (from
 * discussion_board_users/discussion_board_moderators).
 *
 * This API operation authenticates a moderator account by verifying the
 * provided email/username and password combination against the
 * discussion_board_users schema (for identity and password_hash) and the
 * discussion_board_moderators schema (to confirm active moderator status with
 * is_active=true and revoked_at=null). The account must also be
 * is_verified=true. If authentication is successful, the system issues a JWT
 * access token (containing role claims, expiration, and permissions) and a
 * refresh token, as defined by session tables. Failed logins due to invalid
 * credentials, non-verified, suspended, or deleted accounts, or moderator role
 * revocation are rejected with specific errors. Security requirements strictly
 * follow the uniqueness and status fields of the schema, and audit logging of
 * the login event is recommended. This endpoint is only accessible to users
 * already registered as moderators and with fully verified accounts. Works in
 * conjunction with token refresh and security-related endpoints.
 *
 * @param props.connection
 * @param props.body Moderator credentials (email/username and password).
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Moderator credentials (email/username and password). */
    body: IDiscussionBoardModerator.ILogin;
  };
  export type Body = IDiscussionBoardModerator.ILogin;
  export type Response = IDiscussionBoardModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/login";
  export const random = (): IDiscussionBoardModerator.IAuthorized =>
    typia.random<IDiscussionBoardModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh a moderator's JWT access token by valid refresh token (session
 * extension/auth renewal).
 *
 * This operation allows a logged-in moderator to refresh their access session
 * using a valid refresh token. The operation validates that the provided token
 * exists in the discussion_board_refresh_tokens table, is not revoked/expired,
 * and belongs to a discussion_board_user still holding active moderator status
 * (checked in discussion_board_moderators). If the refresh is valid, a new JWT
 * access token (and optionally a new refresh token) is issued with updated
 * expiration, matching the session's permissions and audit policies as required
 * by the schema. Expired or revoked refresh tokens, or loss of moderator
 * privilege, cause the operation to fail. This endpoint is used in session
 * renewal flows, works with login and logout APIs, and adheres to the business
 * logic in the session and actors schema tables.
 *
 * @param props.connection
 * @param props.body Moderator refresh token (from active session).
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Moderator refresh token (from active session). */
    body: IDiscussionBoardModerator.IRefresh;
  };
  export type Body = IDiscussionBoardModerator.IRefresh;
  export type Response = IDiscussionBoardModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/refresh";
  export const random = (): IDiscussionBoardModerator.IAuthorized =>
    typia.random<IDiscussionBoardModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
