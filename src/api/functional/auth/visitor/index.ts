import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardVisitor } from "../../../structures/IDiscussionBoardVisitor";

/**
 * Visitor registration for unauthenticated guest actors in
 * discussion_board_visitors table.
 *
 * This API operation registers a new unauthenticated visitor by creating a
 * record in discussion_board_visitors. It issues a unique visitor_token for
 * session-based tracking without storing PII, and is used for anonymous access
 * onboarding. The endpoint processes registration requests, logs
 * device/IP/user_agent if provided, and ensures soft deletion (via deleted_at)
 * is respected for compliance. Registration enables analytics, basic
 * anti-fraud, auditing, and provides an entry point for privilege escalation
 * should the visitor later choose to register as a full member. Each
 * registration is auditable, aligns strictly to the schema, and avoids overlap
 * with user/member/admin actor tables. Interaction with this endpoint is the
 * first step in the authentication flow for guest users, related to refresh
 * endpoints for session continuation.
 *
 * @param props.connection
 * @param props.body Information required to register a new visitor and open a
 *   new guest session. Can include user_agent and IP for audit/security (if
 *   available).
 * @setHeader token.access Authorization
 *
 * @path /auth/visitor/join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Information required to register a new visitor and open a new guest
     * session. Can include user_agent and IP for audit/security (if
     * available).
     */
    body: IDiscussionBoardVisitor.IJoin;
  };
  export type Body = IDiscussionBoardVisitor.IJoin;
  export type Response = IDiscussionBoardVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/visitor/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/visitor/join";
  export const random = (): IDiscussionBoardVisitor.IAuthorized =>
    typia.random<IDiscussionBoardVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Visitor token/session refresh in discussion_board_visitors (guest actors).
 *
 * This API operation allows an existing visitor to refresh the anonymous
 * session in the discussion_board_visitors table. The endpoint verifies the
 * provided visitor_token against active, non-soft-deleted records (deleted_at),
 * and, if valid, issues a fresh session token to extend guest access. Operation
 * ensures session continuity for unregistered/guest actors, without collecting
 * or exposing PII. Security checks ensure tokens from suspended or soft-deleted
 * records are not refreshed. Acts as a counterpart to the join endpoint and
 * integrates with guest upgrade flows (not handled here). All actions align to
 * strict visitor/guest schema logic, supporting safe anonymous participation
 * and strict audit traceability. No member or admin rights are escalated or
 * exposed from this operation.
 *
 * @param props.connection
 * @param props.body Request payload for refreshing a visitor (guest) session,
 *   must provide valid visitor_token.
 * @setHeader token.access Authorization
 *
 * @path /auth/visitor/refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Request payload for refreshing a visitor (guest) session, must
     * provide valid visitor_token.
     */
    body: IDiscussionBoardVisitor.IRefresh;
  };
  export type Body = IDiscussionBoardVisitor.IRefresh;
  export type Response = IDiscussionBoardVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/visitor/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/visitor/refresh";
  export const random = (): IDiscussionBoardVisitor.IAuthorized =>
    typia.random<IDiscussionBoardVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
