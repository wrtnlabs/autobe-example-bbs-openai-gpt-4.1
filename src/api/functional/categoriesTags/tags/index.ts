import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITag } from "../../../structures/ITag";
import { IPageITag } from "../../../structures/IPageITag";

/**
 * Creates a new, unique tag in the 'tags' Prisma table for thread labeling and
 * filtering.
 *
 * This endpoint enables the creation of a new tag for labeling and filtering
 * threads. Input is strictly validated to ensure the tag name is unique,
 * normalized, and meets system business rules as enforced by the Prisma 'tags'
 * schema (unique constraint on 'name').
 *
 * On success, it returns the complete tag object, including id and timestamps,
 * suitable for use in filter lists or assigning to threads. Only properly
 * authorized users (admin, moderator, or advanced trust level) can create new
 * tags, preventing uncontrolled expansion. Error handling includes duplicate
 * names and format issues. The feature is closely integrated with tag list and
 * thread-tag assignment endpoints. Designed for admin, moderation, or UI
 * workflows needing dynamic tag curation.
 *
 * @param props.body The information required to create a new unique tag (name,
 *   optional metadata).
 * @path /categoriesTags/tags
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * The information required to create a new unique tag (name, optional
     * metadata).
     */
    body: ITag.ICreate;
  };
  export type Body = ITag.ICreate;
  export type Response = ITag;

  export const METADATA = {
    method: "POST",
    path: "/categoriesTags/tags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/categoriesTags/tags";
  export const random = (g?: Partial<typia.IRandomGenerator>): ITag =>
    typia.random<ITag>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves a paginated, filtered list of tags from the 'tags' Prisma table for
 * advanced thread filtering.
 *
 * This endpoint allows clients to retrieve an indexed list of all available
 * tags for labeling and filtering threads. Each tag is represented by unique,
 * normalized attributes (id, name, created_at) from the Prisma 'tags' schema.
 * The endpoint supports flexible search through keyword queries on tag names
 * and advanced filtering by creation date. Sorting by name or newest/oldest is
 * supported for optimal UI/UX in tag pickers.
 *
 * This design follows strict 3NF normalization, ensuring that no duplicate or
 * aggregated tag information is returned—each tag is atomic. Security is
 * generally open to authenticated users, but pagination and rate limiting
 * prevent abuse, especially in large-scale deployments. If business rules grant
 * tag management only to admins/moderators, results can be restricted
 * accordingly.
 *
 * The endpoint returns a paginated structure with total counts and current page
 * details. It's closely related to the tag creation and update endpoints, as
 * well as thread-tag management operations. Robust error handling for malformed
 * queries or filter/sort misuse is essential. This endpoint powers tag
 * search/autocomplete UI in thread creation/edit forms and supports
 * community-driven topic curation.
 *
 * @param props.body Flexible parameters for searching, filtering, and sorting
 *   tags, along with pagination controls.
 * @path /categoriesTags/tags
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Flexible parameters for searching, filtering, and sorting tags, along
     * with pagination controls.
     */
    body: ITag.IRequest;
  };
  export type Body = ITag.IRequest;
  export type Response = IPageITag;

  export const METADATA = {
    method: "PATCH",
    path: "/categoriesTags/tags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/categoriesTags/tags";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageITag =>
    typia.random<IPageITag>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves full details for a single tag from the 'tags' Prisma table by id.
 *
 * This endpoint fetches a single tag's full details by its id, fully aligned
 * with the strict normalization of the 'tags' Prisma schema. It returns atomic
 * tag information including the id, name, and creation timestamp. This enables
 * the UI to show precise tag detail pages, power tag-editing forms, and support
 * admin panels for tag management.
 *
 * Error responses are provided for non-existent or inaccessible tags. The
 * endpoint is essential for implementing tag information popups and for
 * users/admins who wish to update or review tag status. Closely related
 * endpoints are tag list retrieval and tag update. This design prevents
 * information leaks by enforcing proper access policies if tags have restricted
 * visibility.
 *
 * @param props.id Unique identifier of the tag to retrieve.
 * @path /categoriesTags/tags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the tag to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ITag;

  export const METADATA = {
    method: "GET",
    path: "/categoriesTags/tags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/categoriesTags/tags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ITag =>
    typia.random<ITag>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates the details of an existing tag in the 'tags' table, enforcing
 * uniqueness and atomicity.
 *
 * This endpoint allows for updating the attributes of an existing tag, by
 * unique id, in accordance with the Prisma 'tags' schema. Supported
 * modifications include renaming the tag or changing metadata, with strict
 * enforcement of uniqueness and normalization. Only atomic (non-derived) fields
 * may be edited.
 *
 * The endpoint is generally protected for admin/moderator users to maintain tag
 * integrity and prevent spam or misuse. It powers tag edit forms, supports tag
 * curation audits, and enables ongoing improvement of the community's search
 * and filtering experience. Error responses are sent for duplicate names,
 * invalid id, or business rule violations. This is closely related to tag
 * creation and detail retrieval endpoints.
 *
 * @param props.id Unique identifier of the tag to update.
 * @param props.body The updated values for this tag (name, and/or other atomic
 *   metadata).
 * @path /categoriesTags/tags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the tag to update. */
    id: string & tags.Format<"uuid">;

    /** The updated values for this tag (name, and/or other atomic metadata). */
    body: ITag.IUpdate;
  };
  export type Body = ITag.IUpdate;
  export type Response = ITag;

  export const METADATA = {
    method: "PUT",
    path: "/categoriesTags/tags/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/categoriesTags/tags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ITag =>
    typia.random<ITag>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Deletes a tag from the 'tags' table by its unique id, with integrity checks
 * and RBAC enforcement.
 *
 * This endpoint deletes a tag from the database, referenced by its unique id.
 * The operation checks for referential integrity—if the tag is currently
 * associated with any thread via 'thread_tags', deletion is either prevented
 * (error returned) or handled according to business rules (e.g., cascade or
 * soft-delete). The request is typically restricted to admin or moderator
 * users, per the strict RBAC and audit requirements in the requirements docs
 * and Prisma schema.
 *
 * Audit logs may capture the requesting user and time of operation for later
 * review. Related endpoints include tag listing, detail retrieval, and
 * thread/tag linking. Proper error handling ensures that attempts to delete
 * non-existent or referenced tags are handled gracefully.
 *
 * @param props.id Unique identifier of the tag to delete.
 * @path /categoriesTags/tags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the tag to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ITag.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/categoriesTags/tags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/categoriesTags/tags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ITag.IDeleteResult => typia.random<ITag.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
