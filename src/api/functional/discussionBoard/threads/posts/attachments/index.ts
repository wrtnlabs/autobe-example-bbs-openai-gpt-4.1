import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardAttachment } from "../../../../../structures/IDiscussionBoardAttachment";
import { IPageIDiscussionBoardAttachment } from "../../../../../structures/IPageIDiscussionBoardAttachment";

/**
 * Retrieve a paginated, filtered list of file/media attachments for a post.
 *
 * Obtain a filtered, paginated list of attachments for a specific post in a
 * thread (not for comment-attached files). The API supports filtering by file
 * name, uploader, content type, and range. Sort and pagination allow efficient
 * handling for posts with multiple media or file uploads. Only non-deleted
 * (deleted_at is null) attachments are shown to normal users. Moderators/admins
 * may view soft-deleted files for audit purposes. Use cases include user file
 * management, moderator content review, and compliance evidence download.
 * Errors may arise if the post does not exist or user lacks permission to view
 * certain attachment types.
 *
 * @param props.connection
 * @param props.threadId Unique identifier for the parent thread.
 * @param props.postId Unique identifier for the parent post.
 * @param props.body Search, pagination, and filter criteria for retrieving
 *   attachments. May include file name, uploader, date, or type.
 * @path /discussionBoard/threads/:threadId/posts/:postId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier for the parent thread. */
    threadId: string & tags.Format<"uuid">;

    /** Unique identifier for the parent post. */
    postId: string & tags.Format<"uuid">;

    /**
     * Search, pagination, and filter criteria for retrieving attachments.
     * May include file name, uploader, date, or type.
     */
    body: IDiscussionBoardAttachment.IRequest;
  };
  export type Body = IDiscussionBoardAttachment.IRequest;
  export type Response = IPageIDiscussionBoardAttachment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/threads/:threadId/posts/:postId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/attachments`;
  export const random = (): IPageIDiscussionBoardAttachment.ISummary =>
    typia.random<IPageIDiscussionBoardAttachment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get metadata and download information for a single attachment on a post.
 *
 * Fetch the full metadata and access information for a specific file/media
 * attachment tied to a post in a thread. The operation is available for both
 * users (with access rights) and moderators. Regular users cannot see metadata
 * for soft-deleted files, while privileged actors can access for compliance and
 * moderation. Typical output includes upload info, audit fields, and download
 * URI. Supports both client UI renderings and backend compliance processes. API
 * returns permission errors for unqualified users, and 404 errors if the
 * attachment does not exist or is not associated with the post/thread
 * specified.
 *
 * @param props.connection
 * @param props.threadId Unique identifier for the parent thread.
 * @param props.postId Unique identifier for the post containing this
 *   attachment.
 * @param props.attachmentId Unique identifier for the target attachment file.
 * @path /discussionBoard/threads/:threadId/posts/:postId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the parent thread. */
    threadId: string & tags.Format<"uuid">;

    /** Unique identifier for the post containing this attachment. */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier for the target attachment file. */
    attachmentId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardAttachment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/threads/:threadId/posts/:postId/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IDiscussionBoardAttachment =>
    typia.random<IDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
