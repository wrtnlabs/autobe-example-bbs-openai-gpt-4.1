import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardUser } from "../../../../structures/IDiscussionBoardUser";

/**
 * Retrieve detailed user account information by userId from
 * discussion_board_users.
 *
 * Retrieve detailed information about a specific user account in the discussion
 * board. This operation accesses the discussion_board_users table as defined in
 * the Prisma schema and provides all configurable fields and associated user
 * profile data, such as email, username, display_name, verification status, and
 * account state properties.
 *
 * This API is designed for viewing user profile information, viewing
 * participant statistics, and supporting profile display operations in the
 * frontend. The endpoint will enforce security rules so that only authenticated
 * users or users with permissions (e.g., self or authorized roles) can view
 * protected details. Sensitive attributes such as password hashes are not
 * exposed in the response.
 *
 * The API integrates with multiple user-centric operations, supports account
 * moderation states (is_suspended, is_verified), and can be used for displaying
 * user profile pages or self-service account management. Related operations
 * include list, update, and erase endpoints for user management.
 *
 * The API expects a valid userId path parameter in UUID format, matching an
 * existing discussion_board_users record. Clients must handle not-found and
 * unauthorized scenarios in accordance with API error handling conventions.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the target user
 * @path /discussionBoard/user/users/:userId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target user */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardUser;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/user/users/:userId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): IDiscussionBoardUser =>
    typia.random<IDiscussionBoardUser>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update mutable fields of a user profile by userId.
 *
 * Update the mutable, non-sensitive fields of an existing user account
 * identified by userId. This operation is rooted in the discussion_board_users
 * table, allowing changes to the display_name, username, or other updatable
 * fields as defined in the business logic and the Prisma schema.
 *
 * Security measures ensure only the account owner, or authorized roles (e.g.,
 * moderators or admins), may perform updates. Critical fields like password
 * hashes, suspension status, or deletion cannot be updated via this
 * endpoint—instead, such changes are handled by special-purpose APIs. The
 * update timestamp is refreshed and an audit trail is maintained according to
 * compliance policy.
 *
 * Related APIs include the user profile retrieval, account suspension/role
 * assignment, and account erasure endpoints. The expected behavior for updates
 * is transactional integrity and complete validation per business rules (e.g.,
 * username uniqueness).
 *
 * Clients must provide a valid userId in the path and a request body that
 * validates against IDiscussionBoardUser.IUpdate.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user to be updated
 * @param props.body Update request data for the user profile (non-sensitive
 *   fields only)
 * @path /discussionBoard/user/users/:userId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the user to be updated */
    userId: string & tags.Format<"uuid">;

    /** Update request data for the user profile (non-sensitive fields only) */
    body: IDiscussionBoardUser.IUpdate;
  };
  export type Body = IDiscussionBoardUser.IUpdate;
  export type Response = IDiscussionBoardUser;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/user/users/:userId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): IDiscussionBoardUser =>
    typia.random<IDiscussionBoardUser>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete (deactivate) a user account by userId (sets deleted_at).
 *
 * Soft-deletes a user account in the discussion board by marking the deleted_at
 * field with the current timestamp for the user referenced by userId. This
 * operation makes the account inaccessible to regular users but retains the
 * record and key metadata for compliance, moderation, and auditing.
 *
 * Account removal respects all standard soft deletion patterns, meaning all
 * direct relations (posts, comments, etc.) are not removed but may be hidden or
 * anonymized from public view according to business logic. The operation
 * requires self-authorization unless escalated (e.g., by moderators/admins).
 * Complies with user data erasure policies, enabling administrators and users
 * to initiate their own account removal.
 *
 * A successful deletion will only affect logical removal—not physical deletion.
 * Related APIs must handle visibility of soft-deleted records and include
 * compliance with any legal erasure requirements.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the account to be soft-deleted
 * @path /discussionBoard/user/users/:userId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the account to be soft-deleted */
    userId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/user/users/:userId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
