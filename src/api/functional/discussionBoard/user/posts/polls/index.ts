import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardPoll } from "../../../../../structures/IDiscussionBoardPoll";
export * as pollOptions from "./pollOptions";

/**
 * Get detailed metadata for a specific poll on a post by pollId.
 *
 * Retrieves the full details of a specific poll by pollId, including poll
 * options, vote counts, and current status (open/closed). If the poll belongs
 * to a soft-deleted post, the operation returns a 'not found' or compliance
 * error. Returns icons or flags for whether poll is multiple choice, and
 * provides the user's voting status if applicable.
 *
 * This endpoint is open to any authenticated user. Access may be restricted on
 * soft-deleted content. Errors are accompanied by actionable messages for UI
 * integration.
 *
 * This endpoint is usually consumed for rendering poll UIs or for voting
 * interactions in post threads.
 *
 * @param props.connection
 * @param props.postId Identifier of the post this poll belongs to.
 * @param props.pollId Unique identifier of the poll to retrieve.
 * @path /discussionBoard/user/posts/:postId/polls/:pollId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the post this poll belongs to. */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the poll to retrieve. */
    pollId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardPoll;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/user/posts/:postId/polls/:pollId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/posts/${encodeURIComponent(props.postId ?? "null")}/polls/${encodeURIComponent(props.pollId ?? "null")}`;
  export const random = (): IDiscussionBoardPoll =>
    typia.random<IDiscussionBoardPoll>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("pollId")(() => typia.assert(props.pollId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Edit an existing poll on a post. Restricted to authors, moderators, or admins
 * and not allowed if locked/closed.
 *
 * Updates an existing poll (such as changing the title, description, or poll
 * window). Only permitted for post authors, moderators, and admins. Locks and
 * closure dates are considered before modification is allowed. Edits must
 * remain compliant with schema and business logic. All updates are logged for
 * compliance, including changes to poll open/close state.
 *
 * Business logic prevents edits on locked or closed polls and ensures that only
 * the correct users (author, moderator, admin) can perform the update. An error
 * is returned if conditions are not met, such as insufficient privileges,
 * locked polls, or invalid state.
 *
 * @param props.connection
 * @param props.postId Identifier of the post that owns this poll.
 * @param props.pollId Identifier of the poll to update.
 * @param props.body Poll update information including fields to be modified,
 *   such as title, description, and timestamps.
 * @path /discussionBoard/user/posts/:postId/polls/:pollId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the post that owns this poll. */
    postId: string & tags.Format<"uuid">;

    /** Identifier of the poll to update. */
    pollId: string & tags.Format<"uuid">;

    /**
     * Poll update information including fields to be modified, such as
     * title, description, and timestamps.
     */
    body: IDiscussionBoardPoll.IUpdate;
  };
  export type Body = IDiscussionBoardPoll.IUpdate;
  export type Response = IDiscussionBoardPoll;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/user/posts/:postId/polls/:pollId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/posts/${encodeURIComponent(props.postId ?? "null")}/polls/${encodeURIComponent(props.pollId ?? "null")}`;
  export const random = (): IDiscussionBoardPoll =>
    typia.random<IDiscussionBoardPoll>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("pollId")(() => typia.assert(props.pollId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new poll attached to an existing post. Only authors, moderators, and
 * admins are allowed.
 *
 * Creates a new poll on an existing post by postId. The poll can be single- or
 * multi-choice, with validation enforcing both the poll format and the post's
 * ability to accept new polls (not locked or archived). Only the post author,
 * moderators, and admins can use this endpoint. All input data such as poll
 * title, description, and poll options must meet validation as defined in the
 * request DTO schema.
 *
 * The operation logs successful poll creation along with option records for
 * audit and compliance. Attempts to create more than one poll per post or on
 * locked/archived posts are rejected by business logic. Poll creation is
 * atomicâ€”either all records are written or none are saved in case of error.
 *
 * @param props.connection
 * @param props.postId Identifier of the post to which the poll is being
 *   attached.
 * @param props.body Full poll creation data, including required title, options
 *   list, and constraints per the schema.
 * @path /discussionBoard/user/posts/:postId/polls
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Identifier of the post to which the poll is being attached. */
    postId: string & tags.Format<"uuid">;

    /**
     * Full poll creation data, including required title, options list, and
     * constraints per the schema.
     */
    body: IDiscussionBoardPoll.ICreate;
  };
  export type Body = IDiscussionBoardPoll.ICreate;
  export type Response = IDiscussionBoardPoll;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/user/posts/:postId/polls",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/posts/${encodeURIComponent(props.postId ?? "null")}/polls`;
  export const random = (): IDiscussionBoardPoll =>
    typia.random<IDiscussionBoardPoll>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
