import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardJwtToken } from "../../../../structures/IDiscussionBoardJwtToken";
import { IPageIDiscussionBoardJwtToken } from "../../../../structures/IPageIDiscussionBoardJwtToken";

/**
 * List/manage a user's active and historical JWT token sessions.
 *
 * Retrieve a paginated set of active and historical JWT session tokens
 * associated with the current user.
 *
 * This endpoint supports device/session management, audit, and security
 * workflows by allowing users to audit which devices, browsers, and locations
 * have valid tokens for their account. Only tokens belonging to the requesting
 * user are shown.
 *
 * Various filtering criteria, such as token status (active, expired, revoked),
 * issue time/range, and device metadata, may be supported in the query model.
 * Use cases include reviewing suspicious sessions, logging out other devices,
 * and visibility into active sessions for compliance.
 *
 * @param props.connection
 * @param props.body Filtering, sorting, and pagination options for JWT token
 *   query.
 * @path /discussionBoard/user/jwtTokens
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filtering, sorting, and pagination options for JWT token query. */
    body: IDiscussionBoardJwtToken.IRequest;
  };
  export type Body = IDiscussionBoardJwtToken.IRequest;
  export type Response = IPageIDiscussionBoardJwtToken.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/user/jwtTokens",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/user/jwtTokens";
  export const random = (): IPageIDiscussionBoardJwtToken.ISummary =>
    typia.random<IPageIDiscussionBoardJwtToken.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve all information about a single JWT token session by id.
 *
 * Fetch JWT token details for a session matching the provided id. This enables
 * the user to see token metadata including device/browser info, times of issue
 * and expiry, forced logout/revocation state, etc.
 *
 * Requires session ownership: only the requesting user's JWT tokens may be
 * accessed. Used in workflow where a user is reviewing their own authentication
 * sessions for suspicious activity or security audit. Enables compliance with
 * security and privacy policies.
 *
 * @param props.connection
 * @param props.jwtTokenId The UUID id of the JWT token session to retrieve.
 * @path /discussionBoard/user/jwtTokens/:jwtTokenId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The UUID id of the JWT token session to retrieve. */
    jwtTokenId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardJwtToken;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/user/jwtTokens/:jwtTokenId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/jwtTokens/${encodeURIComponent(props.jwtTokenId ?? "null")}`;
  export const random = (): IDiscussionBoardJwtToken =>
    typia.random<IDiscussionBoardJwtToken>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("jwtTokenId")(() => typia.assert(props.jwtTokenId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update (e.g. revoke) a user's JWT token session by id.
 *
 * Update (or revoke) a JWT token session record by id for the authenticated
 * user. Permits device/session logout and state change for auditable control
 * over which sessions remain valid.
 *
 * Security checks prevent modifying token records not owned by the user.
 * Revocation timestamps and updated device_info or metadata may be set. No
 * access to other users' JWT sessions is allowed. Used in security/audit
 * scenarios such as forced device logout or session metadata correction.
 *
 * @param props.connection
 * @param props.jwtTokenId JWT token session id (UUID) to update/revoke.
 * @param props.body Fields to update or revoke the JWT session token (e.g.
 *   revoked_at, device_info).
 * @path /discussionBoard/user/jwtTokens/:jwtTokenId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** JWT token session id (UUID) to update/revoke. */
    jwtTokenId: string & tags.Format<"uuid">;

    /**
     * Fields to update or revoke the JWT session token (e.g. revoked_at,
     * device_info).
     */
    body: IDiscussionBoardJwtToken.IUpdate;
  };
  export type Body = IDiscussionBoardJwtToken.IUpdate;
  export type Response = IDiscussionBoardJwtToken;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/user/jwtTokens/:jwtTokenId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/jwtTokens/${encodeURIComponent(props.jwtTokenId ?? "null")}`;
  export const random = (): IDiscussionBoardJwtToken =>
    typia.random<IDiscussionBoardJwtToken>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("jwtTokenId")(() => typia.assert(props.jwtTokenId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a user's JWT token session by id for privacy/audit hygiene.
 *
 * Soft delete (remove) a JWT token session from visibility for the
 * authenticated user. The deleted_at field is set to hide the session in user
 * interfaces, but the record is retained for audit and compliance. This does
 * not terminate the actual session if the token itself is still valid and not
 * previously revoked.
 *
 * The operation verifies the session's ownership by the requesting user.
 * Attempts to delete (soft-delete) sessions not owned by the user are denied.
 * Already deleted or non-existent sessions result in an error message. This
 * supports user-driven session hygiene and privacy controls.
 *
 * @param props.connection
 * @param props.jwtTokenId Unique identifier of the JWT token session to be soft
 *   deleted (UUID).
 * @path /discussionBoard/user/jwtTokens/:jwtTokenId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the JWT token session to be soft deleted (UUID). */
    jwtTokenId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/user/jwtTokens/:jwtTokenId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/jwtTokens/${encodeURIComponent(props.jwtTokenId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("jwtTokenId")(() => typia.assert(props.jwtTokenId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
