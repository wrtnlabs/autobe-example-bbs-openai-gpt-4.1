import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardVote } from "../../../../structures/IDiscussionBoardVote";
import { IPageIDiscussionBoardVote } from "../../../../structures/IPageIDiscussionBoardVote";

/**
 * Submit a new vote (upvote/downvote) on a post or comment
 * (discussion_board_votes).
 *
 * This operation creates a new vote (upvote/downvote) for a post or comment.
 * Each vote must be unique per user/content combination. On creation, the
 * system validates vote_type ('up' or 'down'), confirms no duplicate votes, and
 * enforces business rules (no self-voting). On passing validation, the new vote
 * record is inserted with links to user and target, audit timestamps, and vote
 * status. Compliance with analytic and moderation policies is enforced. The
 * returned object contains full vote metadata. Important for recording user
 * engagement and powering content quality algorithms.
 *
 * @param props.connection
 * @param props.body Vote creation input: user, content target, vote type
 *   ('up'/'down'), audit basis.
 * @path /discussionBoard/user/votes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Vote creation input: user, content target, vote type ('up'/'down'),
     * audit basis.
     */
    body: IDiscussionBoardVote.ICreate;
  };
  export type Body = IDiscussionBoardVote.ICreate;
  export type Response = IDiscussionBoardVote;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/user/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/user/votes";
  export const random = (): IDiscussionBoardVote =>
    typia.random<IDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list user votes with filtering and pagination
 * (discussion_board_votes).
 *
 * This operation retrieves a searchable, paginated list of all votes
 * (upvotes/downvotes) cast by users on posts and comments. Each vote record is
 * tracked in the discussion_board_votes table and includes links to the voting
 * user, post/comment, vote_type (up/down), timestamps, and soft-delete marker.
 * Filtering options allow result restriction by voter's id, target
 * post/comment, vote type, and creation ranges. Paginated and sorted response
 * enables use in analytics dashboards, user profile voting history, or
 * moderation review panels. Soft-deleted votes are excluded from normal
 * queries; moderators may view for auditing. Essential for engagement analytics
 * and user transparency.
 *
 * @param props.connection
 * @param props.body Flexible search and pagination options for vote query.
 * @path /discussionBoard/user/votes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Flexible search and pagination options for vote query. */
    body: IDiscussionBoardVote.IRequest;
  };
  export type Body = IDiscussionBoardVote.IRequest;
  export type Response = IPageIDiscussionBoardVote;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/user/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/user/votes";
  export const random = (): IPageIDiscussionBoardVote =>
    typia.random<IPageIDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single vote record by its ID (discussion_board_votes).
 *
 * Get detailed information about a single vote (upvote or downvote) by its vote
 * ID. Each vote object includes details on the voter (user), the target content
 * (post or comment), the type ('up'/'down'), creation and update timestamps,
 * and soft-deletion status. The discussion_board_votes model ensures all votes
 * are unique per user/content target and supports retention for
 * compliance/audit. Normal users may only view their own votes;
 * moderators/admins have extended access for moderation and platform analysis.
 * Provides context for application UI (has user already voted, show vote
 * status, etc.) and audit panels.
 *
 * @param props.connection
 * @param props.voteId Unique identifier of the vote (UUID format)
 * @path /discussionBoard/user/votes/:voteId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the vote (UUID format) */
    voteId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardVote;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/user/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): IDiscussionBoardVote =>
    typia.random<IDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing vote (upvote/downvote) for a post or comment by voteId.
 *
 * This API allows an authenticated user to update an existing vote (upvote or
 * downvote) that they have previously cast on a post or comment. The operation
 * validates that the voteId belongs to the current user and that the new vote
 * type is valid ('up' or 'down'), as constrained by the schema. All
 * modifications are logged in the associated history table for audit purposes.
 *
 * Role-based access control ensures only the owner of the vote may update it.
 * Attempts by other users or unauthenticated actors are denied with a clear
 * error message. The endpoint enforces deduplication rules to prevent duplicate
 * voting by the same user on a single piece of content.
 *
 * Business logic ensures that votes cannot be updated for soft-deleted or
 * deleted content, and any attempts to update non-existent votes will return a
 * not found or access denied error. The response includes the updated vote
 * details for immediate UI feedback.
 *
 * If the operation is performed on a vote linked to a soft-deleted post or
 * comment, a business-level error is returned. All updates are reflected in the
 * main table and the detailed vote history log for compliance and traceability.
 * Related endpoints include vote creation (POST), vote retrieval (GET), vote
 * deletion (DELETE), and vote audit trail (GET).
 *
 * @param props.connection
 * @param props.voteId Target vote's unique identifier to update.
 * @param props.body Information needed to perform the vote update, including
 *   the new vote type ('up' or 'down').
 * @path /discussionBoard/user/votes/:voteId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target vote's unique identifier to update. */
    voteId: string & tags.Format<"uuid">;

    /**
     * Information needed to perform the vote update, including the new vote
     * type ('up' or 'down').
     */
    body: IDiscussionBoardVote.IUpdate;
  };
  export type Body = IDiscussionBoardVote.IUpdate;
  export type Response = IDiscussionBoardVote;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/user/votes/:voteId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): IDiscussionBoardVote =>
    typia.random<IDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("voteId")(() => typia.assert(props.voteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete (hard delete) the authenticated user's vote by voteId.
 * This action cannot be undone.
 *
 * This API provides a hard deletion operation for votes by their unique voteId.
 * The endpoint validates that the requesting user owns the vote to be deleted
 * and that the vote exists. If the vote does not exist or the user is not
 * authorized, a not-found or forbidden error code is returned.
 *
 * Vote deletions are performed by completely removing the vote record from the
 * database, even though a 'deleted_at' field exists. This is to avoid duplicate
 * voting and maintain integrity with the deduplication logic.
 *
 * Audit trails are maintained by inserting a deletion event into the vote
 * history, including actor and timestamp, for regulatory and compliance
 * requirements. No restoration is possible after deletion.
 *
 * @param props.connection
 * @param props.voteId Unique identifier of the vote to delete.
 * @path /discussionBoard/user/votes/:voteId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the vote to delete. */
    voteId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/user/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
