import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardNotification } from "../../../../structures/IDiscussionBoardNotification";
import { IPageIDiscussionBoardNotification } from "../../../../structures/IPageIDiscussionBoardNotification";

/**
 * Retrieve a filtered, paginated list of notifications for the authenticated
 * user.
 *
 * This endpoint allows authenticated users to retrieve their notifications in a
 * flexible and efficient manner. Users can filter notifications by type (reply,
 * mention, flag, moderator action, system alert, poll close, etc.), status
 * (unread, read, archived, or failed), and time windows based on creation or
 * delivery timestamps. The operation supports sorting (e.g., newest first,
 * group by status) and paginated delivery for performance at scale.
 *
 * Access control is enforced such that users can only access notifications sent
 * to themselves, with appropriate role and ownership checking. Notification
 * content (title, body, and action_url) is included based on preference and
 * status. Security considerations ensure that notification visibility complies
 * with privacy, moderation, and system alert policies.
 *
 * Related notification operations include marking as read (PUT), deleting
 * (DELETE), and retrieving individual notification (GET by ID). Failure
 * scenarios such as invalid pagination options, inaccessible notifications, or
 * attempts to access others' notifications return precise business errors in
 * accordance with audit policy.
 *
 * @param props.connection
 * @param props.body Filter, search, and pagination criteria for retrieving
 *   notifications.
 * @path /discussionBoard/user/notifications
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter, search, and pagination criteria for retrieving notifications. */
    body: IDiscussionBoardNotification.IRequest;
  };
  export type Body = IDiscussionBoardNotification.IRequest;
  export type Response = IPageIDiscussionBoardNotification;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/user/notifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/user/notifications";
  export const random = (): IPageIDiscussionBoardNotification =>
    typia.random<IPageIDiscussionBoardNotification>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve notification details by notificationId for the authenticated user.
 *
 * Allows an authenticated user to fetch the full details of a single
 * notification sent to them. The response includes all notification metadata
 * (type, status, related actor and post/comment, content, delivery state, and
 * timestamps). Ownership and security checks are enforced to ensure only the
 * intended recipient may access the record. Privacy considerations prohibit any
 * user or role from accessing notifications not addressed to them.
 *
 * Comprehensive notification data supports user interface features such as
 * notification previews, linking back to relevant posts or comments, and
 * context-sensitive actions. Typical failure modes include not found,
 * insufficient permissions, or attempts to access notifications deleted or
 * belonging to others.
 *
 * @param props.connection
 * @param props.notificationId The unique identifier of the notification to
 *   retrieve.
 * @path /discussionBoard/user/notifications/:notificationId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The unique identifier of the notification to retrieve. */
    notificationId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardNotification;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/user/notifications/:notificationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): IDiscussionBoardNotification =>
    typia.random<IDiscussionBoardNotification>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the status of a notification (read, unread, archived, etc.) by
 * notificationId.
 *
 * Authenticated users can use this endpoint to update the status of a
 * notification they have received. Common actions include marking notifications
 * as read, archiving them to declutter the notification center, or restoring
 * notifications to unread if action is needed later.
 *
 * This operation emphasizes strict ownership verification, ensuring users can
 * only update notifications addressed to them. Business logic controls
 * transitions between notification statuses and timestamps related to reading
 * or archiving. Related endpoints allow listing all notifications and fetching
 * details.
 *
 * Error handling includes invalid state transitions and attempts to update
 * already deleted or irreversible notifications. Attempts to manipulate
 * notifications not owned by the user are denied with an explicit business
 * error.
 *
 * @param props.connection
 * @param props.notificationId Identifier of the notification to update.
 * @param props.body New status or updates to apply to the notification (e.g.,
 *   read, archived).
 * @path /discussionBoard/user/notifications/:notificationId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the notification to update. */
    notificationId: string & tags.Format<"uuid">;

    /**
     * New status or updates to apply to the notification (e.g., read,
     * archived).
     */
    body: IDiscussionBoardNotification.IUpdate;
  };
  export type Body = IDiscussionBoardNotification.IUpdate;
  export type Response = IDiscussionBoardNotification;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/user/notifications/:notificationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): IDiscussionBoardNotification =>
    typia.random<IDiscussionBoardNotification>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a notification by its identifier, removing it from the user's
 * notification center.
 *
 * Allows the authenticated user to delete (soft-delete) a notification from
 * their own notification center. The notification is marked as deleted using
 * the deleted_at field, ensuring it is no longer visible to the user but
 * retained for compliance/audit. Only the notification's recipient may perform
 * this operation, and some business rules may prevent deletion of mandatory
 * system or compliance notifications.
 *
 * Related notification endpoints include listing (PATCH), viewing details
 * (GET), and updating status (PUT). Attempts to delete notifications not owned
 * by the user or already deleted notifications will result in clear error
 * messages with audit trail compliance.
 *
 * @param props.connection
 * @param props.notificationId Unique identifier of the notification to delete.
 * @path /discussionBoard/user/notifications/:notificationId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the notification to delete. */
    notificationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/user/notifications/:notificationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
