import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardComment } from "../../../../../../../structures/IDiscussionBoardComment";
import { IPageIDiscussionBoardComment } from "../../../../../../../structures/IPageIDiscussionBoardComment";

/**
 * Create a new reply to a comment (discussion_board_comments).
 *
 * This operation allows an authenticated user to post a new reply beneath an
 * existing comment (as a nested comment) within a thread and post. It records
 * the association via the parent_id and post_id fields, increments the
 * nesting_level, and ensures replies do not exceed a maximum hierarchy depth
 * (usually 5). The request validates presence and length of reply body, checks
 * authorization, and automatically links the reply to the creating user for
 * audit. Soft-deletion and moderation workflows are supported; actions are
 * retained in compliance/audit trails. The response returns the full reply
 * object as created, with standard metadata.
 *
 * @param props.connection
 * @param props.threadId Thread UUID for the reply tree
 * @param props.postId Post UUID to which this reply belongs
 * @param props.commentId Parent comment UUID under which to add the reply
 * @param props.body Body, author, and hierarchy details for new reply creation.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Thread UUID for the reply tree */
    threadId: string & tags.Format<"uuid">;

    /** Post UUID to which this reply belongs */
    postId: string & tags.Format<"uuid">;

    /** Parent comment UUID under which to add the reply */
    commentId: string & tags.Format<"uuid">;

    /** Body, author, and hierarchy details for new reply creation. */
    body: IDiscussionBoardComment.ICreate;
  };
  export type Body = IDiscussionBoardComment.ICreate;
  export type Response = IDiscussionBoardComment;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/replies`;
  export const random = (): IDiscussionBoardComment =>
    typia.random<IDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated, filtered retrieval of all replies to a comment
 * (discussion_board_comments).
 *
 * This operation retrieves all replies (nested comments) under a specific
 * parent comment for a given thread and post. Replies are modeled as
 * discussion_board_comments with their parent_id field referencing the parent
 * comment, and the nesting_level field capturing how deep this comment is in
 * the hierarchy (up to five). The operation returns results with full reply
 * information (text, author, time, nesting, and soft-deletion status), supports
 * filtering by date/user/nesting_level, paginates results for performance, and
 * ensures only non-soft-deleted replies are visible to normal users. Moderators
 * may use additional filters to review hidden/deleted replies. This endpoint is
 * fundamental for rendering threaded conversations and supports sorting (by
 * created_at, nesting_level, etc.).
 *
 * Security: Only authenticated users may see their own hidden/deleted replies;
 * otherwise, replies with deleted_at set are excluded. Moderator/admin roles
 * may receive all results including soft-deleted comments for moderation
 * workflows.
 *
 * @param props.connection
 * @param props.threadId Target thread's unique identifier (UUID format)
 * @param props.postId Target post's unique identifier (UUID format)
 * @param props.commentId Target parent comment's unique identifier (UUID
 *   format)
 * @param props.body Search/filtering and pagination specification for fetching
 *   comment replies.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target thread's unique identifier (UUID format) */
    threadId: string & tags.Format<"uuid">;

    /** Target post's unique identifier (UUID format) */
    postId: string & tags.Format<"uuid">;

    /** Target parent comment's unique identifier (UUID format) */
    commentId: string & tags.Format<"uuid">;

    /**
     * Search/filtering and pagination specification for fetching comment
     * replies.
     */
    body: IDiscussionBoardComment.IRequest;
  };
  export type Body = IDiscussionBoardComment.IRequest;
  export type Response = IPageIDiscussionBoardComment;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/replies`;
  export const random = (): IPageIDiscussionBoardComment =>
    typia.random<IPageIDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch a single reply's detailed information by its ID
 * (discussion_board_comments).
 *
 * Retrieve the full details of a specific reply (nested comment) belonging to a
 * parent comment under a given thread and post. Replies are tracked in the
 * discussion_board_comments table, with fields including author, content,
 * nesting level (for threaded hierarchy up to 5 levels), creation and update
 * timestamps, and optional soft-delete. For normal users, soft-deleted replies
 * are hidden; moderators/admins may retrieve deleted replies as part of
 * moderation. The full reply object includes links to related post and thread,
 * along with edit history if needed for compliance or audit.
 *
 * Security: User authentication is required. Moderators and admins have
 * extended visibility. Returns not found if reply is not visible in context or
 * access is denied.
 *
 * Useful for rendering reply context, supporting moderation, or navigating to
 * specific reply locations in the UI.
 *
 * @param props.connection
 * @param props.threadId Thread UUID to scope lookup
 * @param props.postId Post UUID for reply context
 * @param props.commentId Parent comment UUID for reply
 * @param props.replyId The reply (discussion_board_comments.id) UUID to
 *   retrieve
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies/:replyId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Thread UUID to scope lookup */
    threadId: string & tags.Format<"uuid">;

    /** Post UUID for reply context */
    postId: string & tags.Format<"uuid">;

    /** Parent comment UUID for reply */
    commentId: string & tags.Format<"uuid">;

    /** The reply (discussion_board_comments.id) UUID to retrieve */
    replyId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardComment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies/:replyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/replies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IDiscussionBoardComment =>
    typia.random<IDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("replyId")(() => typia.assert(props.replyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update content of a reply (discussion_board_comments).
 *
 * This operation updates the content of an existing reply beneath a comment on
 * a given thread and post. The reply must be active (not soft-deleted), unless
 * a moderator/admin is performing the update. Only the reply's author,
 * moderators, or admins are permitted to update. Fields subject to update
 * include the reply body and optionally status fields. All updates are tracked
 * with edit histories for full audit compliance. Validation rules enforce
 * proper nesting and soft-delete semantics. Returns full reply object with
 * current state.
 *
 * @param props.connection
 * @param props.threadId Thread UUID for reply tree context
 * @param props.postId Post UUID the reply belongs to
 * @param props.commentId Parent comment UUID
 * @param props.replyId Reply UUID to update
 * @param props.body Updated reply content and metadata. Only updatable fields
 *   are allowed.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies/:replyId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Thread UUID for reply tree context */
    threadId: string & tags.Format<"uuid">;

    /** Post UUID the reply belongs to */
    postId: string & tags.Format<"uuid">;

    /** Parent comment UUID */
    commentId: string & tags.Format<"uuid">;

    /** Reply UUID to update */
    replyId: string & tags.Format<"uuid">;

    /**
     * Updated reply content and metadata. Only updatable fields are
     * allowed.
     */
    body: IDiscussionBoardComment.IUpdate;
  };
  export type Body = IDiscussionBoardComment.IUpdate;
  export type Response = IDiscussionBoardComment;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies/:replyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/replies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IDiscussionBoardComment =>
    typia.random<IDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("replyId")(() => typia.assert(props.replyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a reply under a comment (discussion_board_comments).
 *
 * Deletes a specific reply (nested comment) from a comment thread. This
 * operation performs a soft delete by setting the deleted_at timestamp on the
 * targeted reply (discussion_board_comments record). The reply will no longer
 * be visible to standard users but is retained for moderators, possible
 * restoration, and compliance audits. Only the reply author, moderators, or
 * administrators may execute this operation. All deletions are logged for
 * compliance. If a moderator/admin performs the deletion, the system
 * immediately hides the reply from all users. Soft-deleted data can support
 * future recovery, if needed.
 *
 * @param props.connection
 * @param props.threadId Thread UUID
 * @param props.postId Post UUID
 * @param props.commentId Parent comment UUID
 * @param props.replyId Reply UUID (comment id) to be soft-deleted
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies/:replyId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Thread UUID */
    threadId: string & tags.Format<"uuid">;

    /** Post UUID */
    postId: string & tags.Format<"uuid">;

    /** Parent comment UUID */
    commentId: string & tags.Format<"uuid">;

    /** Reply UUID (comment id) to be soft-deleted */
    replyId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/replies/:replyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/replies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("replyId")(() => typia.assert(props.replyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
