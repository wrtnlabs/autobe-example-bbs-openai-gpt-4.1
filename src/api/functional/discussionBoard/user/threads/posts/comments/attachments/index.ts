import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardAttachment } from "../../../../../../../structures/IDiscussionBoardAttachment";
import { IPageIDiscussionBoardAttachment } from "../../../../../../../structures/IPageIDiscussionBoardAttachment";

/**
 * Upload a new attachment file to a specific comment within a post/thread.
 *
 * Attach a new file to a comment on a post in a thread. The file is saved and
 * linked to the parent comment, and must comply with business and regulatory
 * rules on allowed attachments. Users must be authenticated and own/write the
 * comment or have moderator/admin privileges. All file attachments are
 * monitored for prohibited content and violations.
 *
 * Upon success, file metadata (id, file name, URL, content type, uploader id,
 * upload timestamp) is returned. The parent comment must not be locked,
 * archived, or deleted. Security logic enforces file type and file size quotas.
 * The operation references the discussion_board_attachments schema for
 * compliance and moderation protocols.
 *
 * @param props.connection
 * @param props.threadId ID of the thread containing the comment.
 * @param props.postId ID of the parent post.
 * @param props.commentId ID of the comment to attach the file to.
 * @param props.body Attachment details including file information, uploader,
 *   and link to comment ID.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** ID of the thread containing the comment. */
    threadId: string & tags.Format<"uuid">;

    /** ID of the parent post. */
    postId: string & tags.Format<"uuid">;

    /** ID of the comment to attach the file to. */
    commentId: string & tags.Format<"uuid">;

    /**
     * Attachment details including file information, uploader, and link to
     * comment ID.
     */
    body: IDiscussionBoardAttachment.ICreate;
  };
  export type Body = IDiscussionBoardAttachment.ICreate;
  export type Response = IDiscussionBoardAttachment;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments`;
  export const random = (): IDiscussionBoardAttachment =>
    typia.random<IDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search attachments linked to a specific comment on a post in a
 * thread.
 *
 * Retrieve a paginated, filterable, and sortable list of file or media
 * attachments for a specific comment on a post within a thread. This endpoint
 * supports advanced filtering by file type, upload date, or status, and allows
 * sorting and pagination for efficient navigation in threads with many
 * attachments. Only users with access to the comment (author, moderators,
 * admins) can view attachment metadata that isn't public.
 *
 * Relies on the discussion_board_attachments schema, especially leveraging the
 * comment_id field to filter results. Filtering criteria and pagination must be
 * provided in the request body. Useful for users wishing to see all files
 * attached to a comment, for moderation review, or for managing their own
 * uploads.
 *
 * @param props.connection
 * @param props.threadId Unique identifier of the thread containing the comment
 *   and post.
 * @param props.postId Unique identifier of the parent post.
 * @param props.commentId Unique identifier of the comment whose attachments are
 *   listed.
 * @param props.body Filtering, sorting, and pagination query parameters for
 *   attachment list.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the thread containing the comment and post. */
    threadId: string & tags.Format<"uuid">;

    /** Unique identifier of the parent post. */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the comment whose attachments are listed. */
    commentId: string & tags.Format<"uuid">;

    /**
     * Filtering, sorting, and pagination query parameters for attachment
     * list.
     */
    body: IDiscussionBoardAttachment.IRequest;
  };
  export type Body = IDiscussionBoardAttachment.IRequest;
  export type Response = IPageIDiscussionBoardAttachment;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments`;
  export const random = (): IPageIDiscussionBoardAttachment =>
    typia.random<IPageIDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get full metadata for a specified attachment on a comment in a thread/post.
 *
 * Fetch full metadata for a single attachment linked to a comment on a specific
 * post within a thread. Users must be authenticated and have proper
 * authorization (comment author, post author, moderators, or admin) to access
 * restricted or non-public file information. Response includes metadata such as
 * attachment ID, file name, URL, content type, file size, upload timestamp, and
 * uploader identity. Results are drawn from the discussion_board_attachments
 * model using thread, post, comment, and attachment IDs as context.
 *
 * Returns access error if attachment does not exist, is deleted, or the user
 * lacks sufficient privileges.
 *
 * @param props.connection
 * @param props.threadId Thread ID containing the comment.
 * @param props.postId Post ID containing the target comment.
 * @param props.commentId Comment ID for the parent comment.
 * @param props.attachmentId Attachment ID to query for full details.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Thread ID containing the comment. */
    threadId: string & tags.Format<"uuid">;

    /** Post ID containing the target comment. */
    postId: string & tags.Format<"uuid">;

    /** Comment ID for the parent comment. */
    commentId: string & tags.Format<"uuid">;

    /** Attachment ID to query for full details. */
    attachmentId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardAttachment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IDiscussionBoardAttachment =>
    typia.random<IDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update attachment metadata for a file attached to a comment in a post/thread.
 *
 * Edit (update) the metadata for a specific file attachment on a comment. Only
 * permitted for the file owner (uploader) or privileged actors
 * (moderator/admin). The API accepts updates only for allowed attributes (file
 * name, content type), with strict validation, audit, and compliance logging.
 * Attempts to update non-editable properties such as the file content or URL
 * are rejected. If the attachment is deleted or the user lacks permission, the
 * system responds with proper error handling and audit record.
 *
 * All changes are routed through the discussion_board_attachments schema’s
 * update logic, ensuring proper relationship with comment, post, and thread.
 *
 * @param props.connection
 * @param props.threadId Thread ID for parent context.
 * @param props.postId Post ID holding the target comment.
 * @param props.commentId Comment ID owning the attachment.
 * @param props.attachmentId Attachment ID to update.
 * @param props.body New metadata values (file name, content type) to update.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Thread ID for parent context. */
    threadId: string & tags.Format<"uuid">;

    /** Post ID holding the target comment. */
    postId: string & tags.Format<"uuid">;

    /** Comment ID owning the attachment. */
    commentId: string & tags.Format<"uuid">;

    /** Attachment ID to update. */
    attachmentId: string & tags.Format<"uuid">;

    /** New metadata values (file name, content type) to update. */
    body: IDiscussionBoardAttachment.IUpdate;
  };
  export type Body = IDiscussionBoardAttachment.IUpdate;
  export type Response = IDiscussionBoardAttachment;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments/:attachmentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IDiscussionBoardAttachment =>
    typia.random<IDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete an attachment from a comment, retaining metadata for compliance.
 *
 * Soft-delete a file/media attachment from a comment (within a post/thread).
 * The operation sets the attachment's deleted_at timestamp. Only the uploader,
 * moderator, or admin can access the endpoint, and the parent comment must not
 * be deleted or locked. Soft-deleted attachments remain for audit and
 * regulatory review, but are no longer visible in user APIs. If the attachment
 * does not exist or is already deleted, the endpoint returns an error. All
 * actions are audited.
 *
 * @param props.connection
 * @param props.threadId Thread ID for parent container.
 * @param props.postId Post ID housing the comment and attachment.
 * @param props.commentId Comment ID for the parent comment.
 * @param props.attachmentId Attachment ID to be soft deleted.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Thread ID for parent container. */
    threadId: string & tags.Format<"uuid">;

    /** Post ID housing the comment and attachment. */
    postId: string & tags.Format<"uuid">;

    /** Comment ID for the parent comment. */
    commentId: string & tags.Format<"uuid">;

    /** Attachment ID to be soft deleted. */
    attachmentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/comments/:commentId/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
