import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardAttachment } from "../../../../../../structures/IDiscussionBoardAttachment";

/**
 * Upload a new attachment to a specified post in a thread.
 *
 * Create a new file or media attachment for a post within a discussion thread.
 * The user must be authenticated and authorized to upload, and the post must
 * not be locked or archived. If successful, the file metadata and access URI is
 * returned. File uploads are audited for compliance and are subject to
 * moderation and content policy review. Only the post author and moderators may
 * manage attachments. Security rules validate MIME type and enforce per-file
 * size limits. Error handling includes invalid format, exceeding size quotas,
 * or uploading to a deleted/locked/archived post.
 *
 * Authorization requires user authentication as either a regular user,
 * moderator, or admin. All uploads are logged in the audit log for compliance.
 * The operation references the discussion_board_attachments model and ensures
 * relational integrity with the parent post.
 *
 * @param props.connection
 * @param props.threadId Unique identifier of the thread containing the post.
 * @param props.postId Unique identifier of the post to attach the file to.
 * @param props.body Attachment metadata including file details, uploaded by the
 *   user.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the thread containing the post. */
    threadId: string & tags.Format<"uuid">;

    /** Unique identifier of the post to attach the file to. */
    postId: string & tags.Format<"uuid">;

    /** Attachment metadata including file details, uploaded by the user. */
    body: IDiscussionBoardAttachment.ICreate;
  };
  export type Body = IDiscussionBoardAttachment.ICreate;
  export type Response = IDiscussionBoardAttachment;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/attachments`;
  export const random = (): IDiscussionBoardAttachment =>
    typia.random<IDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update metadata for a specific attachment on a post within a thread.
 *
 * Update file attachment metadata for a specific attachment belonging to a
 * post. Only the user who uploaded the file, a moderator, or an admin may
 * update attachment metadata (such as file name or content type). Changing the
 * physical file contents or URL is not supported through this operation. The
 * parent post must not be locked or archived, and the attachment must not be
 * soft deleted.
 *
 * All update actions are logged for compliance in audit logs. Business
 * validation ensures only allowed fields are changed and all field constraints
 * are respected. If attachment does not exist, is not owned by the user, or
 * permissions are insufficient, access is denied with an error. Refer to
 * discussion_board_attachments schema for updatable fields.
 *
 * @param props.connection
 * @param props.threadId Unique identifier of the thread containing the post.
 * @param props.postId Unique identifier of the post that owns the attachment.
 * @param props.attachmentId Unique identifier of the attachment to update.
 * @param props.body Updated attachment metadata (file name, content type,
 *   etc.).
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the thread containing the post. */
    threadId: string & tags.Format<"uuid">;

    /** Unique identifier of the post that owns the attachment. */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the attachment to update. */
    attachmentId: string & tags.Format<"uuid">;

    /** Updated attachment metadata (file name, content type, etc.). */
    body: IDiscussionBoardAttachment.IUpdate;
  };
  export type Body = IDiscussionBoardAttachment.IUpdate;
  export type Response = IDiscussionBoardAttachment;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/attachments/:attachmentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IDiscussionBoardAttachment =>
    typia.random<IDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete an attachment from a post in a thread, retaining record for
 * compliance.
 *
 * Soft-delete a file or media attachment from a post in a thread. Only the
 * upload owner, moderator, or admin can perform this operation. Deletion is
 * recorded by setting the "deleted_at" timestamp, retaining the record for
 * audit and compliance. Once deleted, the attachment is no longer accessible or
 * displayed in user-facing APIs or the post/thread content view. Operations are
 * fully audited as per platform regulations.
 *
 * If the attachment or its parent post is already deleted or does not exist, an
 * appropriate error is returned. Business logic ensures no permanent erase
 * unless enforced by regulatory action. This endpoint operates on the
 * discussion_board_attachments model and requires validation of threadId,
 * postId, and attachmentId.
 *
 * @param props.connection
 * @param props.threadId Unique identifier for the discussion thread.
 * @param props.postId Unique identifier for the post from which the attachment
 *   will be deleted.
 * @param props.attachmentId Identifier for the attachment to soft-delete.
 * @path /discussionBoard/user/threads/:threadId/posts/:postId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the discussion thread. */
    threadId: string & tags.Format<"uuid">;

    /**
     * Unique identifier for the post from which the attachment will be
     * deleted.
     */
    postId: string & tags.Format<"uuid">;

    /** Identifier for the attachment to soft-delete. */
    attachmentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/user/threads/:threadId/posts/:postId/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/user/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
