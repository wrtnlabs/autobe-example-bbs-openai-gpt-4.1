import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardPrivacyDashboard } from "../../../../structures/IDiscussionBoardPrivacyDashboard";
import { IPageIDiscussionBoardPrivacyDashboard } from "../../../../structures/IPageIDiscussionBoardPrivacyDashboard";

/**
 * Create a new compliance privacy dashboard record for user data access/export.
 *
 * Creates a new privacy dashboard record, used to track a user's request for
 * data access or privacy report export as required for regulatory (GDPR/CCPA)
 * compliance. This operation is only used by compliance staff, automation, or
 * admin workflowsâ€”not normal end users.
 *
 * Request body captures all required metadata: user, time of request,
 * (optionally) link to fulfillment/export, and the generated privacy summary
 * information. All access and creation of privacy dashboard records must be
 * auditable for regulatory reasons. Duplicate records for the same user and
 * request datetime are prohibited by schema uniqueness.
 *
 * Appropriate validation is required to ensure only authorized staff/systems
 * invoke this API, and that all provided information conforms to the schema and
 * privacy requirements.
 *
 * @param props.connection
 * @param props.body Data access/export event metadata and details for privacy
 *   dashboard creation
 * @path /discussionBoard/admin/privacyDashboards
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data access/export event metadata and details for privacy dashboard
     * creation
     */
    body: IDiscussionBoardPrivacyDashboard.ICreate;
  };
  export type Body = IDiscussionBoardPrivacyDashboard.ICreate;
  export type Response = IDiscussionBoardPrivacyDashboard;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/admin/privacyDashboards",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/privacyDashboards";
  export const random = (): IDiscussionBoardPrivacyDashboard =>
    typia.random<IDiscussionBoardPrivacyDashboard>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list privacy dashboards for compliance export/audit.
 *
 * This operation provides compliance and admin users with a
 * paginated/searchable collection of privacy dashboards. Each dashboard entry
 * summarizes a user's data access/export history, including generated privacy
 * reports, data portability files, and export URIs. Complex filtering by user,
 * request time, or completion status is supported to facilitate regulatory
 * review and incident-response investigations.
 *
 * Privacy dashboard entries are generated when a user requests data
 * access/export; this API allows staff to efficiently locate, examine, and
 * verify fulfillment of such requests. Use-case examples include regular audit
 * reviews, responding to regulatory inquiries, and supporting data subject
 * rights fulfillment.
 *
 * Sensitive fields in dashboard_payload and export_file_uri are redacted or
 * filtered per role. Best practices are to allow only authorized admins access,
 * and to trace all access for compliance.
 *
 * @param props.connection
 * @param props.body Filtering, searching, and paging criteria for privacy
 *   dashboard listing
 * @path /discussionBoard/admin/privacyDashboards
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filtering, searching, and paging criteria for privacy dashboard
     * listing
     */
    body: IDiscussionBoardPrivacyDashboard.IRequest;
  };
  export type Body = IDiscussionBoardPrivacyDashboard.IRequest;
  export type Response = IPageIDiscussionBoardPrivacyDashboard;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/admin/privacyDashboards",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/privacyDashboards";
  export const random = (): IPageIDiscussionBoardPrivacyDashboard =>
    typia.random<IPageIDiscussionBoardPrivacyDashboard>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a compliance privacy dashboard entry.
 *
 * Retrieves the full detail of a privacy dashboard export, including the time
 * of user access request, fulfillment status, and links to any generated export
 * files. This endpoint is intended for compliance audits or in response to
 * user-initiated access/portability requests, so only admins or compliance
 * officers may access it.
 *
 * All details relating to fulfilled data portability, JSON dashboards, and
 * associated files are exposed to admins. For privacy reasons, user ownership
 * of the record must be validated. The operation should be fully auditable,
 * tracking all accesses for compliance.
 *
 * @param props.connection
 * @param props.privacyDashboardId Unique ID of the privacy dashboard to
 *   retrieve
 * @path /discussionBoard/admin/privacyDashboards/:privacyDashboardId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique ID of the privacy dashboard to retrieve */
    privacyDashboardId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardPrivacyDashboard;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/privacyDashboards/:privacyDashboardId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/privacyDashboards/${encodeURIComponent(props.privacyDashboardId ?? "null")}`;
  export const random = (): IDiscussionBoardPrivacyDashboard =>
    typia.random<IDiscussionBoardPrivacyDashboard>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("privacyDashboardId")(() =>
        typia.assert(props.privacyDashboardId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a compliance privacy dashboard entry for user data export/access.
 *
 * Updates an existing privacy dashboard entry, used for adjusting fields such
 * as fulfillment status, export file URI, or dashboard summary content for a
 * user data access/export request. This supports compliance investigations,
 * corrections based on regulatory queries, and repair of potentially incomplete
 * or previously errored exports.
 *
 * Only compliance, regulatory, or admin staff are permitted to invoke this
 * operation, which enforces schema-level field constraints and uniqueness where
 * applicable. All modifications must be logged and auditable for compliance
 * review. The privacy dashboard updated by this endpoint is identified by its
 * unique ID in the path.
 *
 * @param props.connection
 * @param props.privacyDashboardId Unique ID of the privacy dashboard to update
 * @param props.body Fields to update on the privacy dashboard record (status,
 *   export URI, summary)
 * @path /discussionBoard/admin/privacyDashboards/:privacyDashboardId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique ID of the privacy dashboard to update */
    privacyDashboardId: string & tags.Format<"uuid">;

    /**
     * Fields to update on the privacy dashboard record (status, export URI,
     * summary)
     */
    body: IDiscussionBoardPrivacyDashboard.IUpdate;
  };
  export type Body = IDiscussionBoardPrivacyDashboard.IUpdate;
  export type Response = IDiscussionBoardPrivacyDashboard;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/privacyDashboards/:privacyDashboardId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/privacyDashboards/${encodeURIComponent(props.privacyDashboardId ?? "null")}`;
  export const random = (): IDiscussionBoardPrivacyDashboard =>
    typia.random<IDiscussionBoardPrivacyDashboard>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("privacyDashboardId")(() =>
        typia.assert(props.privacyDashboardId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently (soft) delete a compliance privacy dashboard record by ID.
 *
 * Deletes a privacy dashboard record from the compliance management tables,
 * reflecting removal of a data subject access/export event record. This
 * operation supports soft deletion by populating the deleted_at timestamp. All
 * deletion operations must be logged for compliance, and records should remain
 * available for audit review until regulatory retention windows expire.
 *
 * Access to this operation is strictly limited to compliance staff and system
 * admins. The endpoint accepts the privacy dashboard ID in the path, and does
 * not require a request body. Deletion is performed on the record, not on
 * exported/user data itself.
 *
 * @param props.connection
 * @param props.privacyDashboardId Unique ID of the privacy dashboard entry to
 *   delete
 * @path /discussionBoard/admin/privacyDashboards/:privacyDashboardId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique ID of the privacy dashboard entry to delete */
    privacyDashboardId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/privacyDashboards/:privacyDashboardId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/privacyDashboards/${encodeURIComponent(props.privacyDashboardId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("privacyDashboardId")(() =>
        typia.assert(props.privacyDashboardId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
