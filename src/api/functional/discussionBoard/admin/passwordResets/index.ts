import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardPasswordReset } from "../../../../structures/IDiscussionBoardPasswordReset";
import { IPageIDiscussionBoardPasswordReset } from "../../../../structures/IPageIDiscussionBoardPasswordReset";

/**
 * Get filterable list of password reset token records for audit or account
 * recovery management.
 *
 * Retrieves a filtered and paginated list of all password reset records. This
 * allows clients to audit and review reset flows, rate-limiting, user status,
 * and usage statistics for compliance and security. Filtering supports lookup
 * by user, token status (used or pending), expiration window, and time-based
 * review. Authorization is strictly enforced to admins or the owner. Sensitive
 * reset token values are to be masked in business logic. Errors include access
 * denied, validation failures, or out-of-range pagination queries. Related
 * endpoints allow inspection, update, and deletion of individual password reset
 * events.
 *
 * @param props.connection
 * @param props.body Paginated search/filter definition for reset token events.
 * @path /discussionBoard/admin/passwordResets
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Paginated search/filter definition for reset token events. */
    body: IDiscussionBoardPasswordReset.IRequest;
  };
  export type Body = IDiscussionBoardPasswordReset.IRequest;
  export type Response = IPageIDiscussionBoardPasswordReset;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/admin/passwordResets",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/passwordResets";
  export const random = (): IPageIDiscussionBoardPasswordReset =>
    typia.random<IPageIDiscussionBoardPasswordReset>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get reset token flow detail by passwordResetId for support or account
 * recovery.
 *
 * Retrieves details for a specific password reset flow event, given its unique
 * identifier (UUID). Useful during ongoing reset for status verification or,
 * for admins, to investigate anomalous password resets. Returns all metadata
 * except for actual raw reset token (excluded for security compliance unless
 * policy permits visibility to admins). Authorization is enforced for owners or
 * admins. Handles not-found and unauthorized access as distinct error cases.
 * Related: password reset request, verify, update/reset actions.
 *
 * @param props.connection
 * @param props.passwordResetId Password reset record's unique ID (UUID) to view
 *   details for.
 * @path /discussionBoard/admin/passwordResets/:passwordResetId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Password reset record's unique ID (UUID) to view details for. */
    passwordResetId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardPasswordReset;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/passwordResets/:passwordResetId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/passwordResets/${encodeURIComponent(props.passwordResetId ?? "null")}`;
  export const random = (): IDiscussionBoardPasswordReset =>
    typia.random<IDiscussionBoardPasswordReset>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("passwordResetId")(() =>
        typia.assert(props.passwordResetId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a password reset request record (e.g., mark as used or extend) by ID.
 *
 * Updates information for a password reset event, typically to mark it as used
 * after a successful reset, extend expiry under policy, or add support/audit
 * metadata. This operation supports account recovery, support scenarios, and
 * admin compliance investigations. Only specific fields (used_at, expires_at)
 * are mutable; all others are immutable. Authorization is based on admin rights
 * or token ownership. Error handling includes validation errors for invalid
 * field modification and access control violations. Related endpoints: reset
 * token list, single reset retrieval, deletion/cleanup of expired or used
 * tokens.
 *
 * @param props.connection
 * @param props.passwordResetId Unique identifier (UUID) of the password reset
 *   entry to update.
 * @param props.body Fields to update in one password reset record (e.g.,
 *   used_at, expires_at).
 * @path /discussionBoard/admin/passwordResets/:passwordResetId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the password reset entry to update. */
    passwordResetId: string & tags.Format<"uuid">;

    /**
     * Fields to update in one password reset record (e.g., used_at,
     * expires_at).
     */
    body: IDiscussionBoardPasswordReset.IUpdate;
  };
  export type Body = IDiscussionBoardPasswordReset.IUpdate;
  export type Response = IDiscussionBoardPasswordReset;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/passwordResets/:passwordResetId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/passwordResets/${encodeURIComponent(props.passwordResetId ?? "null")}`;
  export const random = (): IDiscussionBoardPasswordReset =>
    typia.random<IDiscussionBoardPasswordReset>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("passwordResetId")(() =>
        typia.assert(props.passwordResetId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a password reset event for audit, cleanup, or GDPR compliance.
 *
 * Deletes (soft-delete, by setting deleted_at) a password reset record in the
 * system by its unique ID. Used for cleaning up expired or used tokens, or
 * handling data retention in compliance scenarios. Only token owners or
 * administrators may utilize this operation, with all deletions preserved for
 * audit. Error responses are defined for cases where the resource is not found,
 * already deleted, or when unauthorized access is attempted. Related APIs allow
 * retrieval and update for both audit and recovery support.
 *
 * @param props.connection
 * @param props.passwordResetId UUID of the password reset record to delete.
 * @path /discussionBoard/admin/passwordResets/:passwordResetId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the password reset record to delete. */
    passwordResetId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/passwordResets/:passwordResetId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/passwordResets/${encodeURIComponent(props.passwordResetId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("passwordResetId")(() =>
        typia.assert(props.passwordResetId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
