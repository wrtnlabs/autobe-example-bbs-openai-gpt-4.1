import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardPoll } from "../../../../../structures/IDiscussionBoardPoll";
import { IPageIDiscussionBoardPoll } from "../../../../../structures/IPageIDiscussionBoardPoll";
export * as pollOptions from "./pollOptions";

/**
 * Create a new poll attached to an existing post. Only authors, moderators, and
 * admins are allowed.
 *
 * Creates a new poll on an existing post by postId. The poll can be single- or
 * multi-choice, with validation enforcing both the poll format and the post's
 * ability to accept new polls (not locked or archived). Only the post author,
 * moderators, and admins can use this endpoint. All input data such as poll
 * title, description, and poll options must meet validation as defined in the
 * request DTO schema.
 *
 * The operation logs successful poll creation along with option records for
 * audit and compliance. Attempts to create more than one poll per post or on
 * locked/archived posts are rejected by business logic. Poll creation is
 * atomicâ€”either all records are written or none are saved in case of error.
 *
 * @param props.connection
 * @param props.postId Identifier of the post to which the poll is being
 *   attached.
 * @param props.body Full poll creation data, including required title, options
 *   list, and constraints per the schema.
 * @path /discussionBoard/admin/posts/:postId/polls
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Identifier of the post to which the poll is being attached. */
    postId: string & tags.Format<"uuid">;

    /**
     * Full poll creation data, including required title, options list, and
     * constraints per the schema.
     */
    body: IDiscussionBoardPoll.ICreate;
  };
  export type Body = IDiscussionBoardPoll.ICreate;
  export type Response = IDiscussionBoardPoll;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/admin/posts/:postId/polls",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/posts/${encodeURIComponent(props.postId ?? "null")}/polls`;
  export const random = (): IDiscussionBoardPoll =>
    typia.random<IDiscussionBoardPoll>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of polls for a given postId.
 *
 * Returns a paginated and filterable list of all polls associated with a
 * specific post, supporting filters such as poll status, type, and date range.
 * This endpoint is intended primarily for moderators and admins for the purpose
 * of audit, review, or bulk analysis rather than regular users.
 *
 * Access enforcement ensures that only privileged roles (moderator, admin) can
 * perform bulk retrieval or search of poll data on posts. Payloads are
 * optimized for both search/sort and for integration with UI dashboards.
 *
 * If there are no polls for the post, an empty result set is returned with
 * pagination metadata. This endpoint complements single poll GETs and poll
 * management operations.
 *
 * @param props.connection
 * @param props.postId Identifier of the parent post to retrieve polls for.
 * @param props.body Search, filter, and pagination options for polls associated
 *   with the postId.
 * @path /discussionBoard/admin/posts/:postId/polls
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Identifier of the parent post to retrieve polls for. */
    postId: string & tags.Format<"uuid">;

    /**
     * Search, filter, and pagination options for polls associated with the
     * postId.
     */
    body: IDiscussionBoardPoll.IRequest;
  };
  export type Body = IDiscussionBoardPoll.IRequest;
  export type Response = IPageIDiscussionBoardPoll.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/admin/posts/:postId/polls",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/posts/${encodeURIComponent(props.postId ?? "null")}/polls`;
  export const random = (): IPageIDiscussionBoardPoll.ISummary =>
    typia.random<IPageIDiscussionBoardPoll.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Edit an existing poll on a post. Restricted to authors, moderators, or admins
 * and not allowed if locked/closed.
 *
 * Updates an existing poll (such as changing the title, description, or poll
 * window). Only permitted for post authors, moderators, and admins. Locks and
 * closure dates are considered before modification is allowed. Edits must
 * remain compliant with schema and business logic. All updates are logged for
 * compliance, including changes to poll open/close state.
 *
 * Business logic prevents edits on locked or closed polls and ensures that only
 * the correct users (author, moderator, admin) can perform the update. An error
 * is returned if conditions are not met, such as insufficient privileges,
 * locked polls, or invalid state.
 *
 * @param props.connection
 * @param props.postId Identifier of the post that owns this poll.
 * @param props.pollId Identifier of the poll to update.
 * @param props.body Poll update information including fields to be modified,
 *   such as title, description, and timestamps.
 * @path /discussionBoard/admin/posts/:postId/polls/:pollId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the post that owns this poll. */
    postId: string & tags.Format<"uuid">;

    /** Identifier of the poll to update. */
    pollId: string & tags.Format<"uuid">;

    /**
     * Poll update information including fields to be modified, such as
     * title, description, and timestamps.
     */
    body: IDiscussionBoardPoll.IUpdate;
  };
  export type Body = IDiscussionBoardPoll.IUpdate;
  export type Response = IDiscussionBoardPoll;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/posts/:postId/polls/:pollId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/posts/${encodeURIComponent(props.postId ?? "null")}/polls/${encodeURIComponent(props.pollId ?? "null")}`;
  export const random = (): IDiscussionBoardPoll =>
    typia.random<IDiscussionBoardPoll>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("pollId")(() => typia.assert(props.pollId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a poll attached to a post. Only moderators and admins are
 * authorized.
 *
 * Deletes (soft delete) a poll attached to a post by setting the 'deleted_at'
 * timestamp. Only moderators and admins can perform poll deletions. The
 * operation is denied if the poll is in active use or is protected by a locked
 * or archived parent post. On success, the poll remains recoverable for
 * compliance until a subsequent hard deletion by a system process. Audit trail
 * logs are created for all deletions. Users without privilege, or those
 * attempting to delete already-soft-deleted polls receive a business error.
 *
 * @param props.connection
 * @param props.postId Identifier of the parent post for this poll.
 * @param props.pollId Identifier of the poll to delete.
 * @path /discussionBoard/admin/posts/:postId/polls/:pollId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Identifier of the parent post for this poll. */
    postId: string & tags.Format<"uuid">;

    /** Identifier of the poll to delete. */
    pollId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/posts/:postId/polls/:pollId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/posts/${encodeURIComponent(props.postId ?? "null")}/polls/${encodeURIComponent(props.pollId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("pollId")(() => typia.assert(props.pollId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
