import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardModerationAction } from "../../../../structures/IDiscussionBoardModerationAction";

/**
 * Create a new moderation action (warn, remove, restrict, etc.) by a moderator
 * or admin.
 *
 * Create a new moderation action record to log activity performed by moderators
 * or admins for enforcement of platform policies. This includes actions against
 * users, posts, or commentsâ€”such as warning, restricting, muting, removing, or
 * restoring content. The API requires identifying the acting moderator, the
 * target (user, post, or comment), specifying the type of moderation action
 * (e.g., warn, mute, remove, restore), the reason for the action, and relevant
 * effective timing. All actions are recorded in the moderation_actions schema
 * for audit and compliance.
 *
 * Security is ensured by restricting this endpoint to users with moderator or
 * admin roles; each action taken is logged and auditable. Linked records must
 * exist in the target tables (users, posts, or comments). Business logic will
 * validate action-specific requirements (such as only allowing restore actions
 * on content previously removed), and rejection reasons are clearly reported.
 *
 * Expected behavior includes auditing/traceability and propagation of
 * moderation effects to related user/content state. This endpoint upholds
 * community integrity, enables regulatory compliance, and is a primary
 * interface for staff moderation activities.
 *
 * @param props.connection
 * @param props.body Information about the moderation action to record,
 *   including action type, target, reason, and timing.
 * @path /discussionBoard/admin/moderationActions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information about the moderation action to record, including action
     * type, target, reason, and timing.
     */
    body: IDiscussionBoardModerationAction.ICreate;
  };
  export type Body = IDiscussionBoardModerationAction.ICreate;
  export type Response = IDiscussionBoardModerationAction;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/admin/moderationActions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/moderationActions";
  export const random = (): IDiscussionBoardModerationAction =>
    typia.random<IDiscussionBoardModerationAction>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing moderation action record (e.g., restriction reason/time).
 *
 * Update (modify) an existing moderation action. This endpoint allows
 * moderators or admins to change the moderation action parameters, such as
 * action type, affected user/post/comment, reason, or restriction timeframe.
 * Changes are fully audited and tracked in the database to preserve historical
 * state and regulatory compliance.
 *
 * This operation ensures consistency and traceability for all moderation
 * enforcement history. Security is strict, with access limited to users having
 * moderator or admin roles. The operation checks existence of the moderation
 * action and validates appropriate permissions on both the action and the
 * affected target.
 *
 * All updates are logged for compliance, with business validation on which
 * fields may be changed post-creation, and responses include updated moderation
 * action records.
 *
 * @param props.connection
 * @param props.moderationActionId Unique identifier for the target moderation
 *   action to update.
 * @param props.body Updates to apply to the moderation action, such as reason,
 *   type, timing, or affected entity.
 * @path /discussionBoard/admin/moderationActions/:moderationActionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the target moderation action to update. */
    moderationActionId: string & tags.Format<"uuid">;

    /**
     * Updates to apply to the moderation action, such as reason, type,
     * timing, or affected entity.
     */
    body: IDiscussionBoardModerationAction.IUpdate;
  };
  export type Body = IDiscussionBoardModerationAction.IUpdate;
  export type Response = IDiscussionBoardModerationAction;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/moderationActions/:moderationActionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/moderationActions/${encodeURIComponent(props.moderationActionId ?? "null")}`;
  export const random = (): IDiscussionBoardModerationAction =>
    typia.random<IDiscussionBoardModerationAction>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationActionId")(() =>
        typia.assert(props.moderationActionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete (retire) a moderation action for audit compliance.
 *
 * Soft delete (retire) a specific moderation action, setting its deleted_at
 * timestamp for logical deletion and audit compliance. The record remains
 * visible in audits but not returned in regular API queries. Only moderators or
 * admins can perform this function; the API enforces permissions and validates
 * action existence. Soft-deleted moderation actions cannot be enforced and are
 * treated as obsolete in business workflows.
 *
 * Every record soft-deleted here is auditable and traceable. Attempting to
 * delete a non-existent or already retired moderation action will result in a
 * clear error. Soft deletion supports legal compliance, as all moderation
 * changes remain discoverable in case of investigation.
 *
 * @param props.connection
 * @param props.moderationActionId Unique ID of the moderation action to soft
 *   delete.
 * @path /discussionBoard/admin/moderationActions/:moderationActionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<erase.Response> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique ID of the moderation action to soft delete. */
    moderationActionId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardModerationAction;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/moderationActions/:moderationActionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/moderationActions/${encodeURIComponent(props.moderationActionId ?? "null")}`;
  export const random = (): IDiscussionBoardModerationAction =>
    typia.random<IDiscussionBoardModerationAction>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationActionId")(() =>
        typia.assert(props.moderationActionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
