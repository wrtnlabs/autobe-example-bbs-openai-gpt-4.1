import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardAdmin } from "../../../../../structures/IDiscussionBoardAdmin";

/**
 * Assign or update admin privileges for a user (discussion_board_admins).
 *
 * Grant administrator privileges to a user by creating or updating an admin
 * record tied to the provided userId. This operation is restricted to existing
 * administrators.
 *
 * Privileges include the highest-level access on the platform, with assignment
 * and revocation recorded for auditing. Each assignment should be unique and
 * not overlap with suspended or revoked records. This endpoint follows
 * regulatory role management rules and is fully auditable.
 *
 * All admin assignments are managed via this single admin table. The endpoint
 * validates user status, ensures idempotency, and triggers notifications if
 * business logic so requires.
 *
 * @param props.connection
 * @param props.userId Target user ID for admin privilege assignment.
 * @param props.body Admin assignment details.
 * @path /discussionBoard/admin/users/:userId/admin
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function assignAdmin(
  connection: IConnection,
  props: assignAdmin.Props,
): Promise<assignAdmin.Response> {
  return true === connection.simulate
    ? assignAdmin.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...assignAdmin.METADATA,
          path: assignAdmin.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace assignAdmin {
  export type Props = {
    /** Target user ID for admin privilege assignment. */
    userId: string & tags.Format<"uuid">;

    /** Admin assignment details. */
    body: IDiscussionBoardAdmin.ICreate;
  };
  export type Body = IDiscussionBoardAdmin.ICreate;
  export type Response = IDiscussionBoardAdmin;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/users/:userId/admin",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/users/${encodeURIComponent(props.userId ?? "null")}/admin`;
  export const random = (): IDiscussionBoardAdmin =>
    typia.random<IDiscussionBoardAdmin>();
  export const simulate = (
    connection: IConnection,
    props: assignAdmin.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: assignAdmin.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Restore/reinstate admin privilege for a user in discussion_board_admins.
 *
 * Restore the admin role for a user with the provided userId by reactivating or
 * reinstating a previously-revoked administrator record. This endpoint allows
 * the admin team to re-elevate prior admins who may have been suspended or
 * revoked in the past.
 *
 * Security checks ensure only admins may access this feature. The response
 * confirms the admin's privileges have been reinstated, with current status and
 * metadata. All such actions are logged for audit/compliance.
 *
 * Related operations include creating new admin assignments and revoking or
 * suspending admin access. The admins table is the primary store for this
 * privilege.
 *
 * @param props.connection
 * @param props.userId User ID to reinstate as admin.
 * @param props.body Details for admin reinstatement (generally minimal, but
 *   allows for justifications or assignment options).
 * @path /discussionBoard/admin/users/:userId/admin
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function reinstateAdmin(
  connection: IConnection,
  props: reinstateAdmin.Props,
): Promise<reinstateAdmin.Response> {
  return true === connection.simulate
    ? reinstateAdmin.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...reinstateAdmin.METADATA,
          path: reinstateAdmin.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace reinstateAdmin {
  export type Props = {
    /** User ID to reinstate as admin. */
    userId: string & tags.Format<"uuid">;

    /**
     * Details for admin reinstatement (generally minimal, but allows for
     * justifications or assignment options).
     */
    body: IDiscussionBoardAdmin.IUpdate;
  };
  export type Body = IDiscussionBoardAdmin.IUpdate;
  export type Response = IDiscussionBoardAdmin;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/admin/users/:userId/admin",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/users/${encodeURIComponent(props.userId ?? "null")}/admin`;
  export const random = (): IDiscussionBoardAdmin =>
    typia.random<IDiscussionBoardAdmin>();
  export const simulate = (
    connection: IConnection,
    props: reinstateAdmin.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: reinstateAdmin.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke admin privilege from a user (discussion_board_admins).
 *
 * Revoke administrator privileges for the given user by soft deleting the
 * corresponding record in discussion_board_admins. This operation updates the
 * admin's assignment row with a deleted_at timestamp, inactivating their admin
 * status, but retains audit history for compliance.
 *
 * Revocation is only available to users with admin role, and the system
 * validates assignment before proceeding. Attempts to revoke non-existent or
 * already-revoked admin privileges will result in a clear error.
 *
 * This endpoint completes the privilege management cycle, allowing full
 * compliance with escalation and demotion workflows. It also supports audit,
 * export, and compliance tracing features.
 *
 * @param props.connection
 * @param props.userId ID of user to revoke admin privileges from.
 * @path /discussionBoard/admin/users/:userId/admin
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function revokeAdmin(
  connection: IConnection,
  props: revokeAdmin.Props,
): Promise<revokeAdmin.Response> {
  return true === connection.simulate
    ? revokeAdmin.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...revokeAdmin.METADATA,
          path: revokeAdmin.path(props),
          status: null,
        },
      );
}
export namespace revokeAdmin {
  export type Props = {
    /** ID of user to revoke admin privileges from. */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardAdmin;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/users/:userId/admin",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/users/${encodeURIComponent(props.userId ?? "null")}/admin`;
  export const random = (): IDiscussionBoardAdmin =>
    typia.random<IDiscussionBoardAdmin>();
  export const simulate = (
    connection: IConnection,
    props: revokeAdmin.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: revokeAdmin.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
