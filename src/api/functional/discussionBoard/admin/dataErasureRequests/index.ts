import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardDataErasureRequest } from "../../../../structures/IDiscussionBoardDataErasureRequest";
import { IPageIDiscussionBoardDataErasureRequest } from "../../../../structures/IPageIDiscussionBoardDataErasureRequest";

/**
 * Create and submit a new GDPR/CCPA data erasure request.
 *
 * Submit a new data erasure request to the platform, according to rights under
 * GDPR, CCPA, or similar, for account or content deletion.
 *
 * This POST endpoint receives all required erasure request data, such as type
 * (full, partial, etc.), justification, and references to the submitting user.
 * Validations occur for user status and eligibility, and detailed audit trail
 * is created. A summary of the newly created request is returned in the
 * response for recordkeeping, monitoring, or user-facing privacy dashboards.
 * Privacy protocols and access restrictions align to those described in the
 * schema and the business requirements.
 *
 * @param props.connection
 * @param props.body Data required for a new erasure request submission
 * @path /discussionBoard/admin/dataErasureRequests
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Data required for a new erasure request submission */
    body: IDiscussionBoardDataErasureRequest.ICreate;
  };
  export type Body = IDiscussionBoardDataErasureRequest.ICreate;
  export type Response = IDiscussionBoardDataErasureRequest;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/admin/dataErasureRequests",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/dataErasureRequests";
  export const random = (): IDiscussionBoardDataErasureRequest =>
    typia.random<IDiscussionBoardDataErasureRequest>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve data erasure requests for compliance, privacy, or user
 * review.
 *
 * Retrieve a filtered, paginated list of data erasure requests.
 *
 * This API allows administrators (or, where permitted, users) to find, filter,
 * and paginate requests for account or data erasure under privacy regulations
 * such as GDPR or CCPA. Filters support request status, type (full account,
 * partial, post-only, etc.), time range, or user association.
 *
 * All response records expose only summary or non-sensitive details to respect
 * user privacy and regulatory boundaries. This operation inherently supports
 * privacy dashboards, compliance monitoring, and proactive incident response as
 * described in the business requirements and schema. Access is role-based:
 * admins and compliance officers may see all; users may only see their own
 * requests.
 *
 * @param props.connection
 * @param props.body Advanced search/filter/group criteria for data erasure
 *   requests
 * @path /discussionBoard/admin/dataErasureRequests
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Advanced search/filter/group criteria for data erasure requests */
    body: IDiscussionBoardDataErasureRequest.IRequest;
  };
  export type Body = IDiscussionBoardDataErasureRequest.IRequest;
  export type Response = IPageIDiscussionBoardDataErasureRequest.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/admin/dataErasureRequests",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/dataErasureRequests";
  export const random = (): IPageIDiscussionBoardDataErasureRequest.ISummary =>
    typia.random<IPageIDiscussionBoardDataErasureRequest.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a data erasure request by its ID.
 *
 * Retrieve the details and full history of a user data erasure request by its
 * unique identifier.
 *
 * This endpoint provides complete audit, compliance, and support insight into
 * an individual erasure request, consistent with privacy law protocols. Exposed
 * data includes request lifecycle status, type (full/partial), relevant
 * timestamps, justification, agency references, and outcome payloads. The
 * operation cross-references the user for full compliance context and business
 * workflow integration. All actions are subject to user privacy and compliance
 * disclosure policies specified in the schema.
 *
 * @param props.connection
 * @param props.dataErasureRequestId Unique identifier for the data erasure
 *   request
 * @path /discussionBoard/admin/dataErasureRequests/:dataErasureRequestId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the data erasure request */
    dataErasureRequestId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardDataErasureRequest;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/dataErasureRequests/:dataErasureRequestId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/dataErasureRequests/${encodeURIComponent(props.dataErasureRequestId ?? "null")}`;
  export const random = (): IDiscussionBoardDataErasureRequest =>
    typia.random<IDiscussionBoardDataErasureRequest>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("dataErasureRequestId")(() =>
        typia.assert(props.dataErasureRequestId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update compliance details or status on a data erasure request.
 *
 * Update compliance or administrative status fields for an existing data
 * erasure request, aligning with business, privacy, and regulatory needs.
 *
 * Allowable updates include changing the request's status, admin/verification
 * metadata, processed timestamp, or adding outcome details (response_payload).
 * No alteration of the original submitting user or erasure request type is
 * permitted for integrity. All changes are fully logged for legal and
 * compliance safety. Only authorized compliance or admin roles may invoke this
 * operation.
 *
 * @param props.connection
 * @param props.dataErasureRequestId ID of the data erasure request to update
 * @param props.body Data for compliance/admin fields to update on the erasure
 *   request
 * @path /discussionBoard/admin/dataErasureRequests/:dataErasureRequestId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** ID of the data erasure request to update */
    dataErasureRequestId: string & tags.Format<"uuid">;

    /** Data for compliance/admin fields to update on the erasure request */
    body: IDiscussionBoardDataErasureRequest.IUpdate;
  };
  export type Body = IDiscussionBoardDataErasureRequest.IUpdate;
  export type Response = IDiscussionBoardDataErasureRequest;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/dataErasureRequests/:dataErasureRequestId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/dataErasureRequests/${encodeURIComponent(props.dataErasureRequestId ?? "null")}`;
  export const random = (): IDiscussionBoardDataErasureRequest =>
    typia.random<IDiscussionBoardDataErasureRequest>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("dataErasureRequestId")(() =>
        typia.assert(props.dataErasureRequestId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a data erasure request for compliance/audit management.
 *
 * This operation permanently deletes a user data erasure request from the
 * compliance records. The data erasure request is modelled in the
 * discussion_board_data_erasure_requests table, which tracks user-initiated
 * GDPR/CCPA-style requests for account/data removal.
 *
 * Administrators use this endpoint to remove a specific erasure request after
 * appropriate review or compliance handling. Deletion is performed via hard
 * delete unless soft deletion (using deleted_at) is enabled. Access is strictly
 * limited to admins to preserve regulatory compliance and auditability,
 * ensuring that only authorized staff can manage or remove erasure records.
 *
 * If the erasure request record includes personally identifiable justification,
 * regulator references, or response payloads (per the schema), these are also
 * irreversibly removed. Auditability must be preserved by logging all delete
 * actions involving compliance records.
 *
 * @param props.connection
 * @param props.dataErasureRequestId Unique ID of the data erasure request to
 *   delete
 * @path /discussionBoard/admin/dataErasureRequests/:dataErasureRequestId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique ID of the data erasure request to delete */
    dataErasureRequestId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/dataErasureRequests/:dataErasureRequestId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/dataErasureRequests/${encodeURIComponent(props.dataErasureRequestId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("dataErasureRequestId")(() =>
        typia.assert(props.dataErasureRequestId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
