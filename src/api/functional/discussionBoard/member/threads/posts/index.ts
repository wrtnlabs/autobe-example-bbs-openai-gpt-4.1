import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIDiscussionBoardPost } from "../../../../../structures/IPageIDiscussionBoardPost";
import { IDiscussionBoardPost } from "../../../../../structures/IDiscussionBoardPost";

/**
 * Retrieve a list of posts for a specific thread from the
 * discussion_board_posts table.
 *
 * This API operation retrieves a list of all posts associated with a specified
 * thread in the discussion board system. Posts are returned with their full
 * details and current (non-deleted) status, as enforced by the
 * discussion_board_posts schema. The operation validates user role—guests may
 * browse public posts but cannot access restricted or deleted content.
 * Pagination and sorting parameters are expected to handle large discussions
 * efficiently. Security checks ensure only active (not soft-deleted) posts are
 * presented to typical users, with additional permission validation allowing
 * moderators or admins to review hidden/deleted posts as appropriate. Any error
 * in thread ID format or access rights results in a clear error response. This
 * API is typically consumed by thread viewers or topic participants.
 *
 * @param props.connection
 * @param props.threadId Unique identifier of the parent discussion thread whose
 *   posts should be retrieved.
 * @path /discussionBoard/member/threads/:threadId/posts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the parent discussion thread whose posts should
     * be retrieved.
     */
    threadId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIDiscussionBoardPost;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/member/threads/:threadId/posts",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/threads/${encodeURIComponent(props.threadId ?? "null")}/posts`;
  export const random = (): IPageIDiscussionBoardPost =>
    typia.random<IPageIDiscussionBoardPost>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new post in a thread (insert into discussion_board_posts).
 *
 * This API endpoint allows a registered member to create a new post under a
 * specified thread. Request body provides the required details aligned with
 * IDiscussionBoardPost.ICreate and does not include system-generated fields
 * like id, created_at, or deleted_at. The operation validates posting
 * permissions: only authenticated members, moderators, and admins may create
 * posts. Further, it checks the thread's status (cannot post in closed threads)
 * and may enforce posting cooldown or duplicate prevention for spam mitigation.
 * Related error handling addresses invalid input, unauthorized access, or
 * attempts to post in closed/deleted threads.
 *
 * @param props.connection
 * @param props.threadId ID of the thread to associate the new post with.
 * @param props.body Data needed to create a new post (body, creator_member_id,
 *   etc) under the thread.
 * @path /discussionBoard/member/threads/:threadId/posts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** ID of the thread to associate the new post with. */
    threadId: string & tags.Format<"uuid">;

    /**
     * Data needed to create a new post (body, creator_member_id, etc) under
     * the thread.
     */
    body: IDiscussionBoardPost.ICreate;
  };
  export type Body = IDiscussionBoardPost.ICreate;
  export type Response = IDiscussionBoardPost;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/member/threads/:threadId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/threads/${encodeURIComponent(props.threadId ?? "null")}/posts`;
  export const random = (): IDiscussionBoardPost =>
    typia.random<IDiscussionBoardPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search, filter, and paginate posts for a thread with advanced criteria.
 *
 * This API allows clients to submit complex search and filter criteria for
 * posts within a specified thread. It references the discussion_board_posts
 * table and enables searching by content, author, edit status,
 * creation/modification dates, and soft-deletion (deleted_at). The request body
 * follows the IDiscussionBoardPost.IRequest contract for search parameters. The
 * operation enforces role-based restrictions, ensuring advanced filters are
 * only available to authenticated members or above. Security features include
 * rate limiting and output filtering to respect user roles and board privacy
 * settings. The response delivers paginated search results. Related endpoints
 * may include simple list retrieval and single post detail fetch for deeper
 * exploration. Errors from invalid threadId, search criteria, or authorization
 * are reported in detail.
 *
 * @param props.connection
 * @param props.threadId Unique identifier for the thread to search within.
 * @param props.body Advanced filter, search, and pagination criteria for posts
 *   within the specified thread.
 * @path /discussionBoard/member/threads/:threadId/posts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Unique identifier for the thread to search within. */
    threadId: string & tags.Format<"uuid">;

    /**
     * Advanced filter, search, and pagination criteria for posts within the
     * specified thread.
     */
    body: IDiscussionBoardPost.IRequest;
  };
  export type Body = IDiscussionBoardPost.IRequest;
  export type Response = IPageIDiscussionBoardPost;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/member/threads/:threadId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/threads/${encodeURIComponent(props.threadId ?? "null")}/posts`;
  export const random = (): IPageIDiscussionBoardPost =>
    typia.random<IPageIDiscussionBoardPost>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed info on one post in a thread from the discussion_board_posts
 * table.
 *
 * This endpoint returns the detailed information of a single post within a
 * given thread based on both the unique threadId and postId. Underlying data
 * comes from the discussion_board_posts table—a single row is selected and
 * returned as an IDiscussionBoardPost response body. Security logic ensures
 * proper authorization and role-based filtering: only visible, non-deleted
 * posts are accessible to standard users, while moderation roles can retrieve
 * soft-deleted or flagged posts. Input parameter validation, detailed error
 * reporting, and consistency with related retrieval endpoints are guaranteed.
 * This operation is closely related to post list/search endpoints and supports
 * drill-down user flows.
 *
 * @param props.connection
 * @param props.threadId ID of the thread the post belongs to.
 * @param props.postId ID of the post to retrieve.
 * @path /discussionBoard/member/threads/:threadId/posts/:postId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** ID of the thread the post belongs to. */
    threadId: string & tags.Format<"uuid">;

    /** ID of the post to retrieve. */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardPost;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/member/threads/:threadId/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): IDiscussionBoardPost =>
    typia.random<IDiscussionBoardPost>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a post's content in a thread (update discussion_board_posts record).
 *
 * This endpoint allows for the modification of a post under a particular
 * thread. Based on IDiscussionBoardPost.IUpdate, it lets authorized users
 * (creators, moderators, or admins) edit applicable properties—typically the
 * body content and is_edited status. Write operations are checked for
 * permissions, ensuring that a regular member can only update their own posts,
 * while moderation roles may update any post as allowed by moderation policy.
 * The request does not handle deletion or restoration; it only updates editable
 * post fields. Full error handling for unauthorized, invalid input, or
 * non-existent records is provided. An audit trail is updated for compliance.
 *
 * @param props.connection
 * @param props.threadId ID of the parent thread containing the post.
 * @param props.postId ID of the post to update.
 * @param props.body Updatable post fields (body, is_edited, etc).
 * @path /discussionBoard/member/threads/:threadId/posts/:postId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** ID of the parent thread containing the post. */
    threadId: string & tags.Format<"uuid">;

    /** ID of the post to update. */
    postId: string & tags.Format<"uuid">;

    /** Updatable post fields (body, is_edited, etc). */
    body: IDiscussionBoardPost.IUpdate;
  };
  export type Body = IDiscussionBoardPost.IUpdate;
  export type Response = IDiscussionBoardPost;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/member/threads/:threadId/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): IDiscussionBoardPost =>
    typia.random<IDiscussionBoardPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a post in a thread (update deleted_at for
 * discussion_board_posts).
 *
 * This operation marks an existing post as deleted by setting the deleted_at
 * field (soft delete) in the discussion_board_posts table. Authorization checks
 * require the current user to be the post creator or a moderator/admin. Members
 * cannot delete others' posts. Audit logging of the deletion is performed for
 * traceability. The operation returns confirmation rather than post details,
 * and related endpoints include post restoration (if available) or hard delete
 * (per system policy).
 *
 * @param props.connection
 * @param props.threadId Thread containing the post to delete.
 * @param props.postId ID of the post to mark as deleted.
 * @path /discussionBoard/member/threads/:threadId/posts/:postId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Thread containing the post to delete. */
    threadId: string & tags.Format<"uuid">;

    /** ID of the post to mark as deleted. */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/member/threads/:threadId/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/threads/${encodeURIComponent(props.threadId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
