import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardFlagReport } from "../../../../structures/IDiscussionBoardFlagReport";
import { IPageIDiscussionBoardFlagReport } from "../../../../structures/IPageIDiscussionBoardFlagReport";

/**
 * Search, filter, and retrieve a paginated list of all user-submitted content
 * flag reports.
 *
 * Retrieve a paginated list of all content flag reports for moderation review.
 * This endpoint exposes all flag reports submitted by users who have observed
 * inappropriate, abusive, or policy-violating behavior in posts or comments.
 * The operation supports advanced filtering by flag status (pending, triaged,
 * dismissed, accepted, escalated), content type (post/comment), report reason,
 * reporter, creation timestamp, and reviewed status.
 *
 * The response is designed for use by moderators and administrators. It allows
 * rapid triage and decision-making on reported content. Integration with user,
 * post, and comment information enables moderators to investigate the flagged
 * context fully. Deleted (soft deleted) reports are excluded from general
 * review lists unless specifically requested, fulfilling audit and compliance
 * expectations.
 *
 * Pagination, sorting, and search capabilities follow platform-wide standards
 * for moderator tooling, enabling large-volume queue management and efficient
 * workflow prioritization.
 *
 * @param props.connection
 * @param props.body Filtering, pagination, and sorting criteria for flag report
 *   retrieval, with support for status filtering, content type filters, and
 *   free-text keyword search.
 * @path /discussionBoard/moderator/flagReports
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filtering, pagination, and sorting criteria for flag report
     * retrieval, with support for status filtering, content type filters,
     * and free-text keyword search.
     */
    body: IDiscussionBoardFlagReport.IRequest;
  };
  export type Body = IDiscussionBoardFlagReport.IRequest;
  export type Response = IPageIDiscussionBoardFlagReport.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/moderator/flagReports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/moderator/flagReports";
  export const random = (): IPageIDiscussionBoardFlagReport.ISummary =>
    typia.random<IPageIDiscussionBoardFlagReport.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a single content flag report by its unique identifier.
 *
 * Retrieve the full details of a specific content flag report identified by its
 * unique flagReportId. The operation exposes all relevant report information,
 * including the reporter identities (user), flagged post/comment context,
 * reason for reporting, and all review lifecycle metadata.
 *
 * Intended for use by moderators and admins for in-depth investigation or
 * audit. Includes review timestamps, moderation actions, and status (pending,
 * dismissed, accepted, escalated, etc.). The endpoint enforces required
 * permission checks to restrict detailed report data to authorized staff only.
 *
 * This endpoint supports business logic for moderation triage, follow-up
 * actions, audit trails, and compliance with transparency requirements.
 *
 * @param props.connection
 * @param props.flagReportId Unique identifier of the flag report to retrieve.
 * @path /discussionBoard/moderator/flagReports/:flagReportId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the flag report to retrieve. */
    flagReportId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardFlagReport;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/moderator/flagReports/:flagReportId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/moderator/flagReports/${encodeURIComponent(props.flagReportId ?? "null")}`;
  export const random = (): IDiscussionBoardFlagReport =>
    typia.random<IDiscussionBoardFlagReport>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("flagReportId")(() => typia.assert(props.flagReportId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing content flag report to reflect review or status changes.
 *
 * Update an existing content flag report as part of the moderation workflow.
 * Moderators and admins may change the status (such as from 'pending' to
 * 'triaged', 'accepted', 'dismissed', or 'escalated'), set reviewed timestamps,
 * or update moderator notes based on the investigation outcome.
 *
 * Immutable fields such as reporter, post, comment, and original submission
 * data remain unchanged. The operation enforces audit trails by updating the
 * updated_at field and may append moderator comments as permitted by schema and
 * business rules. Fields subject to update must reflect business process
 * constraints and ensure accuracy for compliance review.
 *
 * Permission checks require the actor to have moderator or admin status. The
 * API response includes the updated flag report entity for further workflow
 * integration, such as status display or audit export.
 *
 * @param props.connection
 * @param props.flagReportId Unique identifier of the flag report to update.
 * @param props.body Fields to update in the flag report; typically moderation
 *   status and notes.
 * @path /discussionBoard/moderator/flagReports/:flagReportId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the flag report to update. */
    flagReportId: string & tags.Format<"uuid">;

    /**
     * Fields to update in the flag report; typically moderation status and
     * notes.
     */
    body: IDiscussionBoardFlagReport.IUpdate;
  };
  export type Body = IDiscussionBoardFlagReport.IUpdate;
  export type Response = IDiscussionBoardFlagReport;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/moderator/flagReports/:flagReportId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/moderator/flagReports/${encodeURIComponent(props.flagReportId ?? "null")}`;
  export const random = (): IDiscussionBoardFlagReport =>
    typia.random<IDiscussionBoardFlagReport>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("flagReportId")(() => typia.assert(props.flagReportId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a content flag report by marking it as deleted (retained for
 * compliance).
 *
 * Perform a soft deletion of a content flag report, removing it from routine
 * moderation review and user interfaces while preserving the record for
 * compliance, investigation, and future audits. This operation sets the
 * deleted_at field to the current timestamp, making the entry invisible to
 * ordinary queries but retrievable for privileged or audit access as needed by
 * policy.
 *
 * Only moderators and administrators may execute this operation. The deletion
 * does not erase the original report details, context, or review history, in
 * alignment with documented business requirements for compliance and moderation
 * trace reliability.
 *
 * @param props.connection
 * @param props.flagReportId Unique identifier of the flag report to delete
 *   (soft delete).
 * @path /discussionBoard/moderator/flagReports/:flagReportId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the flag report to delete (soft delete). */
    flagReportId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/moderator/flagReports/:flagReportId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/moderator/flagReports/${encodeURIComponent(props.flagReportId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("flagReportId")(() => typia.assert(props.flagReportId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
