import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { post__auth_moderator_join } from "../../../providers/post__auth_moderator_join";
import { post__auth_moderator_login } from "../../../providers/post__auth_moderator_login";
import { post__auth_moderator_refresh } from "../../../providers/post__auth_moderator_refresh";

import { IDiscussionBoardModerator } from "../../../api/structures/IDiscussionBoardModerator";

@Controller("/auth/moderator")
export class AuthModeratorController {
  /**
   * Register a new moderator account and issue initial tokens
   * (discussion_board_users + discussion_board_moderators).
   *
   * This operation allows a new moderator to register an account in the system.
   * It creates a new row in discussion_board_users (which stores authentication
   * credentials for all user-like roles) and issues a JWT access/refresh token
   * pair with role='moderator'. The operation requires (and validates) a unique
   * email and usernameâ€”the fields enforced by the discussion_board_users
   * schema. During registration, password_hash is stored securely, and
   * is_verified is set to false until the moderator completes email
   * confirmation. Upon user creation, the discussion_board_moderators table is
   * updated to link this user with moderator privileges (with assigned_at
   * timestamp set to now, is_active true, and revoked_at null).
   * Security-critical fields such as password_hash and email must adhere to
   * complexity and uniqueness requirements, and any business rule violation
   * will be rejected. This endpoint does not permit immediate login until email
   * is verified, as managed by other schema tables (verification flows not
   * explicitly handled by this call). Works in conjunction with moderator
   * login, token refresh, and email verification APIs.
   *
   * @param connection
   * @param body Moderator registration info (email, username, password,
   *   profile).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IDiscussionBoardModerator.IJoin,
  ): Promise<IDiscussionBoardModerator.IAuthorized> {
    try {
      return await post__auth_moderator_join({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate moderator and issue tokens (from
   * discussion_board_users/discussion_board_moderators).
   *
   * This API operation authenticates a moderator account by verifying the
   * provided email/username and password combination against the
   * discussion_board_users schema (for identity and password_hash) and the
   * discussion_board_moderators schema (to confirm active moderator status with
   * is_active=true and revoked_at=null). The account must also be
   * is_verified=true. If authentication is successful, the system issues a JWT
   * access token (containing role claims, expiration, and permissions) and a
   * refresh token, as defined by session tables. Failed logins due to invalid
   * credentials, non-verified, suspended, or deleted accounts, or moderator
   * role revocation are rejected with specific errors. Security requirements
   * strictly follow the uniqueness and status fields of the schema, and audit
   * logging of the login event is recommended. This endpoint is only accessible
   * to users already registered as moderators and with fully verified accounts.
   * Works in conjunction with token refresh and security-related endpoints.
   *
   * @param connection
   * @param body Moderator credentials (email/username and password).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IDiscussionBoardModerator.ILogin,
  ): Promise<IDiscussionBoardModerator.IAuthorized> {
    try {
      return await post__auth_moderator_login({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh a moderator's JWT access token by valid refresh token (session
   * extension/auth renewal).
   *
   * This operation allows a logged-in moderator to refresh their access session
   * using a valid refresh token. The operation validates that the provided
   * token exists in the discussion_board_refresh_tokens table, is not
   * revoked/expired, and belongs to a discussion_board_user still holding
   * active moderator status (checked in discussion_board_moderators). If the
   * refresh is valid, a new JWT access token (and optionally a new refresh
   * token) is issued with updated expiration, matching the session's
   * permissions and audit policies as required by the schema. Expired or
   * revoked refresh tokens, or loss of moderator privilege, cause the operation
   * to fail. This endpoint is used in session renewal flows, works with login
   * and logout APIs, and adheres to the business logic in the session and
   * actors schema tables.
   *
   * @param connection
   * @param body Moderator refresh token (from active session).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IDiscussionBoardModerator.IRefresh,
  ): Promise<IDiscussionBoardModerator.IAuthorized> {
    try {
      return await post__auth_moderator_refresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
