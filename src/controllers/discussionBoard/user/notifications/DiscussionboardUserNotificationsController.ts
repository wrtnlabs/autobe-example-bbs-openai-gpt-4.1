import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { patch__discussionBoard_user_notifications } from "../../../../providers/patch__discussionBoard_user_notifications";
import { UserAuth } from "../../../../decorators/UserAuth";
import { UserPayload } from "../../../../decorators/payload/UserPayload";
import { get__discussionBoard_user_notifications_$notificationId } from "../../../../providers/get__discussionBoard_user_notifications_$notificationId";
import { put__discussionBoard_user_notifications_$notificationId } from "../../../../providers/put__discussionBoard_user_notifications_$notificationId";
import { delete__discussionBoard_user_notifications_$notificationId } from "../../../../providers/delete__discussionBoard_user_notifications_$notificationId";

import { IPageIDiscussionBoardNotification } from "../../../../api/structures/IPageIDiscussionBoardNotification";
import { IDiscussionBoardNotification } from "../../../../api/structures/IDiscussionBoardNotification";

@Controller("/discussionBoard/user/notifications")
export class DiscussionboardUserNotificationsController {
  /**
   * Retrieve a filtered, paginated list of notifications for the authenticated
   * user.
   *
   * This endpoint allows authenticated users to retrieve their notifications in
   * a flexible and efficient manner. Users can filter notifications by type
   * (reply, mention, flag, moderator action, system alert, poll close, etc.),
   * status (unread, read, archived, or failed), and time windows based on
   * creation or delivery timestamps. The operation supports sorting (e.g.,
   * newest first, group by status) and paginated delivery for performance at
   * scale.
   *
   * Access control is enforced such that users can only access notifications
   * sent to themselves, with appropriate role and ownership checking.
   * Notification content (title, body, and action_url) is included based on
   * preference and status. Security considerations ensure that notification
   * visibility complies with privacy, moderation, and system alert policies.
   *
   * Related notification operations include marking as read (PUT), deleting
   * (DELETE), and retrieving individual notification (GET by ID). Failure
   * scenarios such as invalid pagination options, inaccessible notifications,
   * or attempts to access others' notifications return precise business errors
   * in accordance with audit policy.
   *
   * @param connection
   * @param body Filter, search, and pagination criteria for retrieving
   *   notifications.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @UserAuth()
    user: UserPayload,
    @TypedBody()
    body: IDiscussionBoardNotification.IRequest,
  ): Promise<IPageIDiscussionBoardNotification> {
    try {
      return await patch__discussionBoard_user_notifications({
        user,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve notification details by notificationId for the authenticated user.
   *
   * Allows an authenticated user to fetch the full details of a single
   * notification sent to them. The response includes all notification metadata
   * (type, status, related actor and post/comment, content, delivery state, and
   * timestamps). Ownership and security checks are enforced to ensure only the
   * intended recipient may access the record. Privacy considerations prohibit
   * any user or role from accessing notifications not addressed to them.
   *
   * Comprehensive notification data supports user interface features such as
   * notification previews, linking back to relevant posts or comments, and
   * context-sensitive actions. Typical failure modes include not found,
   * insufficient permissions, or attempts to access notifications deleted or
   * belonging to others.
   *
   * @param connection
   * @param notificationId The unique identifier of the notification to
   *   retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":notificationId")
  public async at(
    @UserAuth()
    user: UserPayload,
    @TypedParam("notificationId")
    notificationId: string & tags.Format<"uuid">,
  ): Promise<IDiscussionBoardNotification> {
    try {
      return await get__discussionBoard_user_notifications_$notificationId({
        user,
        notificationId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update the status of a notification (read, unread, archived, etc.) by
   * notificationId.
   *
   * Authenticated users can use this endpoint to update the status of a
   * notification they have received. Common actions include marking
   * notifications as read, archiving them to declutter the notification center,
   * or restoring notifications to unread if action is needed later.
   *
   * This operation emphasizes strict ownership verification, ensuring users can
   * only update notifications addressed to them. Business logic controls
   * transitions between notification statuses and timestamps related to reading
   * or archiving. Related endpoints allow listing all notifications and
   * fetching details.
   *
   * Error handling includes invalid state transitions and attempts to update
   * already deleted or irreversible notifications. Attempts to manipulate
   * notifications not owned by the user are denied with an explicit business
   * error.
   *
   * @param connection
   * @param notificationId Identifier of the notification to update.
   * @param body New status or updates to apply to the notification (e.g., read,
   *   archived).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":notificationId")
  public async update(
    @UserAuth()
    user: UserPayload,
    @TypedParam("notificationId")
    notificationId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IDiscussionBoardNotification.IUpdate,
  ): Promise<IDiscussionBoardNotification> {
    try {
      return await put__discussionBoard_user_notifications_$notificationId({
        user,
        notificationId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete a notification by its identifier, removing it from the user's
   * notification center.
   *
   * Allows the authenticated user to delete (soft-delete) a notification from
   * their own notification center. The notification is marked as deleted using
   * the deleted_at field, ensuring it is no longer visible to the user but
   * retained for compliance/audit. Only the notification's recipient may
   * perform this operation, and some business rules may prevent deletion of
   * mandatory system or compliance notifications.
   *
   * Related notification endpoints include listing (PATCH), viewing details
   * (GET), and updating status (PUT). Attempts to delete notifications not
   * owned by the user or already deleted notifications will result in clear
   * error messages with audit trail compliance.
   *
   * @param connection
   * @param notificationId Unique identifier of the notification to delete.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":notificationId")
  public async erase(
    @UserAuth()
    user: UserPayload,
    @TypedParam("notificationId")
    notificationId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await delete__discussionBoard_user_notifications_$notificationId({
        user,
        notificationId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
